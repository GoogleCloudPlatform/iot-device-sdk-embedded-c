<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CryptoAuthLib: Basic Crypto API methods (atcab_)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CryptoAuthLib
   </div>
   <div id="projectbrief">Microchip CryptoAuthentication Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00916.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Basic Crypto API methods (atcab_)</div>  </div>
</div><!--header-->
<div class="contents">

<p>These methods provide the most convenient, simple API to CryptoAuth chips.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00992.html">atca_aes_cbc_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00996.html">atca_aes_cmac_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01000.html">atca_aes_ctr_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01004.html">atca_sha256_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga66d0b18bba952f5acdee8cf68b889b75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga66d0b18bba952f5acdee8cf68b889b75">BLOCK_NUMBER</a>(a)&#160;&#160;&#160;(a / 32)</td></tr>
<tr class="separator:ga66d0b18bba952f5acdee8cf68b889b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e5ab0fea07bd91159ab96f18105d1b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga9e5ab0fea07bd91159ab96f18105d1b1">WORD_OFFSET</a>(a)&#160;&#160;&#160;((a % 32) / 4)</td></tr>
<tr class="separator:ga9e5ab0fea07bd91159ab96f18105d1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d0b05dd9b5d0987e24eef9674922ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gad4d0b05dd9b5d0987e24eef9674922ce">ATCA_AES_GCM_IV_STD_LENGTH</a>&#160;&#160;&#160;12</td></tr>
<tr class="separator:gad4d0b05dd9b5d0987e24eef9674922ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa702726fe160635225abc3c1ed421f7e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a00992.html">atca_aes_cbc_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gaa702726fe160635225abc3c1ed421f7e">atca_aes_cbc_ctx_t</a></td></tr>
<tr class="separator:gaa702726fe160635225abc3c1ed421f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05fa8c58bf4408381db8871b0dca64b6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a00996.html">atca_aes_cmac_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga05fa8c58bf4408381db8871b0dca64b6">atca_aes_cmac_ctx_t</a></td></tr>
<tr class="separator:ga05fa8c58bf4408381db8871b0dca64b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52b18f051752d214a2d5b485270f5b15"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a01000.html">atca_aes_ctr_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a></td></tr>
<tr class="separator:ga52b18f051752d214a2d5b485270f5b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga530ccce9f617be7dbf3661e19a4c0546"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a01004.html">atca_sha256_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a></td></tr>
<tr class="separator:ga530ccce9f617be7dbf3661e19a4c0546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c1f62e502c168be9261d2af921e78ba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00916.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a></td></tr>
<tr class="separator:ga4c1f62e502c168be9261d2af921e78ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaff701132013eaac5600dd9fd6253505d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gaff701132013eaac5600dd9fd6253505d">atcab_version</a> (char *ver_str)</td></tr>
<tr class="memdesc:gaff701132013eaac5600dd9fd6253505d"><td class="mdescLeft">&#160;</td><td class="mdescRight">basic API methods are all prefixed with atcab_ (CryptoAuthLib Basic) the fundamental premise of the basic API is it is based on a single interface instance and that instance is global, so all basic API commands assume that one global device is the one to operate on.  <a href="#gaff701132013eaac5600dd9fd6253505d">More...</a><br /></td></tr>
<tr class="separator:gaff701132013eaac5600dd9fd6253505d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gacdc4fa3d2f2f6d197af8c10ab1f288b8">atcab_init</a> (<a class="el" href="a00936.html">ATCAIfaceCfg</a> *cfg)</td></tr>
<tr class="memdesc:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a global ATCADevice object used by Basic API.  <a href="#gacdc4fa3d2f2f6d197af8c10ab1f288b8">More...</a><br /></td></tr>
<tr class="separator:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab22d2a32e6c32c14c4e58ce794ff3ec4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gab22d2a32e6c32c14c4e58ce794ff3ec4">atcab_init_device</a> (<a class="el" href="a00913.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> ca_device)</td></tr>
<tr class="memdesc:gab22d2a32e6c32c14c4e58ce794ff3ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the global ATCADevice object to point to one of your choosing for use with all the atcab_ basic API.  <a href="#gab22d2a32e6c32c14c4e58ce794ff3ec4">More...</a><br /></td></tr>
<tr class="separator:gab22d2a32e6c32c14c4e58ce794ff3ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga3a061c1f96bb641b36fc56b6cb2dd4e4">atcab_release</a> (void)</td></tr>
<tr class="memdesc:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">release (free) the global ATCADevice instance. This must be called in order to release or free up the interface.  <a href="#ga3a061c1f96bb641b36fc56b6cb2dd4e4">More...</a><br /></td></tr>
<tr class="separator:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00913.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga4af82005556c549c30e1c4bd35d4f4e4">atcab_get_device</a> (void)</td></tr>
<tr class="memdesc:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global device object.  <a href="#ga4af82005556c549c30e1c4bd35d4f4e4">More...</a><br /></td></tr>
<tr class="separator:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5802cd6847a837458604db5dbec4a6f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga5802cd6847a837458604db5dbec4a6f0">_atcab_exit</a> (void)</td></tr>
<tr class="memdesc:ga5802cd6847a837458604db5dbec4a6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">common cleanup code which idles the device after any operation  <a href="#ga5802cd6847a837458604db5dbec4a6f0">More...</a><br /></td></tr>
<tr class="separator:ga5802cd6847a837458604db5dbec4a6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3bc620aedd9322d160eece0d8d20c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gad3bc620aedd9322d160eece0d8d20c82">atcab_wakeup</a> (void)</td></tr>
<tr class="memdesc:gad3bc620aedd9322d160eece0d8d20c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">wakeup the CryptoAuth device  <a href="#gad3bc620aedd9322d160eece0d8d20c82">More...</a><br /></td></tr>
<tr class="separator:gad3bc620aedd9322d160eece0d8d20c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gaf47433a371b9fcb8d65a4214cd9e4fa0">atcab_idle</a> (void)</td></tr>
<tr class="memdesc:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">idle the CryptoAuth device  <a href="#gaf47433a371b9fcb8d65a4214cd9e4fa0">More...</a><br /></td></tr>
<tr class="separator:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9475e032c388144c5a0df45d1df182a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga9475e032c388144c5a0df45d1df182a5">atcab_sleep</a> (void)</td></tr>
<tr class="memdesc:ga9475e032c388144c5a0df45d1df182a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">invoke sleep on the CryptoAuth device  <a href="#ga9475e032c388144c5a0df45d1df182a5">More...</a><br /></td></tr>
<tr class="separator:ga9475e032c388144c5a0df45d1df182a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1518196e269b549eec78087abd130de7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga1518196e269b549eec78087abd130de7">atcab_cfg_discover</a> (<a class="el" href="a00936.html">ATCAIfaceCfg</a> cfg_array[], int <a class="el" href="a00918.html#gaffe776513b24d84b39af8ab0930fef7f">max</a>)</td></tr>
<tr class="memdesc:ga1518196e269b549eec78087abd130de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto discovery of crypto auth devices  <a href="#ga1518196e269b549eec78087abd130de7">More...</a><br /></td></tr>
<tr class="separator:ga1518196e269b549eec78087abd130de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdfeb1f8d28039e9b30d4e39b8caa33a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gabdfeb1f8d28039e9b30d4e39b8caa33a">atcab_get_addr</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, uint16_t *addr)</td></tr>
<tr class="memdesc:gabdfeb1f8d28039e9b30d4e39b8caa33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the address given the zone, slot, block, and offset.  <a href="#gabdfeb1f8d28039e9b30d4e39b8caa33a">More...</a><br /></td></tr>
<tr class="separator:gabdfeb1f8d28039e9b30d4e39b8caa33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga7a823d2a391bf80ff336eb2ccbd37412">atcab_get_zone_size</a> (uint8_t zone, uint16_t slot, size_t *size)</td></tr>
<tr class="memdesc:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the specified zone in bytes.  <a href="#ga7a823d2a391bf80ff336eb2ccbd37412">More...</a><br /></td></tr>
<tr class="separator:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad115ce255664a48b80e90ea19c156b79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gad115ce255664a48b80e90ea19c156b79">atcab_aes</a> (uint8_t mode, uint16_t key_id, const uint8_t *aes_in, uint8_t *aes_out)</td></tr>
<tr class="memdesc:gad115ce255664a48b80e90ea19c156b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the AES-128 encrypt, decrypt, or GFM calculation.  <a href="#gad115ce255664a48b80e90ea19c156b79">More...</a><br /></td></tr>
<tr class="separator:gad115ce255664a48b80e90ea19c156b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc9a58dc49f91674213f34fa7bbd05e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gacc9a58dc49f91674213f34fa7bbd05e1">atcab_aes_encrypt</a> (uint16_t key_id, uint8_t key_block, const uint8_t *plaintext, uint8_t *ciphertext)</td></tr>
<tr class="memdesc:gacc9a58dc49f91674213f34fa7bbd05e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an AES-128 encrypt operation with a key in the device.  <a href="#gacc9a58dc49f91674213f34fa7bbd05e1">More...</a><br /></td></tr>
<tr class="separator:gacc9a58dc49f91674213f34fa7bbd05e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9658e84055727e6357cf7ef636b4e398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga9658e84055727e6357cf7ef636b4e398">atcab_aes_decrypt</a> (uint16_t key_id, uint8_t key_block, const uint8_t *ciphertext, uint8_t *plaintext)</td></tr>
<tr class="memdesc:ga9658e84055727e6357cf7ef636b4e398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an AES-128 decrypt operation with a key in the device.  <a href="#ga9658e84055727e6357cf7ef636b4e398">More...</a><br /></td></tr>
<tr class="separator:ga9658e84055727e6357cf7ef636b4e398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5554940ed4c7c7e28652ce6923cf9314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga5554940ed4c7c7e28652ce6923cf9314">atcab_aes_gfm</a> (const uint8_t *h, const uint8_t *input, uint8_t *output)</td></tr>
<tr class="memdesc:ga5554940ed4c7c7e28652ce6923cf9314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a Galois Field Multiply (GFM) operation.  <a href="#ga5554940ed4c7c7e28652ce6923cf9314">More...</a><br /></td></tr>
<tr class="separator:ga5554940ed4c7c7e28652ce6923cf9314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc41b824cdc9b10efa46bcbf74850184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gabc41b824cdc9b10efa46bcbf74850184">atcab_aes_cbc_init</a> (<a class="el" href="a00916.html#gaa702726fe160635225abc3c1ed421f7e">atca_aes_cbc_ctx_t</a> *ctx, uint16_t key_id, uint8_t key_block, const uint8_t *iv)</td></tr>
<tr class="memdesc:gabc41b824cdc9b10efa46bcbf74850184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize context for AES CBC operation.  <a href="#gabc41b824cdc9b10efa46bcbf74850184">More...</a><br /></td></tr>
<tr class="separator:gabc41b824cdc9b10efa46bcbf74850184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7414e3dc8215cedc1bffc6cf576d7d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga7414e3dc8215cedc1bffc6cf576d7d1e">atcab_aes_cbc_encrypt_block</a> (<a class="el" href="a00916.html#gaa702726fe160635225abc3c1ed421f7e">atca_aes_cbc_ctx_t</a> *ctx, const uint8_t *plaintext, uint8_t *ciphertext)</td></tr>
<tr class="memdesc:ga7414e3dc8215cedc1bffc6cf576d7d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt a block of data using CBC mode and a key within the ATECC608A. <a class="el" href="a00916.html#gabc41b824cdc9b10efa46bcbf74850184" title="Initialize context for AES CBC operation. ">atcab_aes_cbc_init()</a> should be called before the first use of this function.  <a href="#ga7414e3dc8215cedc1bffc6cf576d7d1e">More...</a><br /></td></tr>
<tr class="separator:ga7414e3dc8215cedc1bffc6cf576d7d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c66e1b8b31bb87be3de6c9a9084c21e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga7c66e1b8b31bb87be3de6c9a9084c21e">atcab_aes_cbc_decrypt_block</a> (<a class="el" href="a00916.html#gaa702726fe160635225abc3c1ed421f7e">atca_aes_cbc_ctx_t</a> *ctx, const uint8_t *ciphertext, uint8_t *plaintext)</td></tr>
<tr class="memdesc:ga7c66e1b8b31bb87be3de6c9a9084c21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt a block of data using CBC mode and a key within the ATECC608A. <a class="el" href="a00916.html#gabc41b824cdc9b10efa46bcbf74850184" title="Initialize context for AES CBC operation. ">atcab_aes_cbc_init()</a> should be called before the first use of this function.  <a href="#ga7c66e1b8b31bb87be3de6c9a9084c21e">More...</a><br /></td></tr>
<tr class="separator:ga7c66e1b8b31bb87be3de6c9a9084c21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84506ff4105e63823c99527788d36d52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga84506ff4105e63823c99527788d36d52">atcab_aes_cmac_init</a> (<a class="el" href="a00916.html#ga05fa8c58bf4408381db8871b0dca64b6">atca_aes_cmac_ctx_t</a> *ctx, uint16_t key_id, uint8_t key_block)</td></tr>
<tr class="memdesc:ga84506ff4105e63823c99527788d36d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a CMAC calculation using an AES-128 key in the ATECC608A.  <a href="#ga84506ff4105e63823c99527788d36d52">More...</a><br /></td></tr>
<tr class="separator:ga84506ff4105e63823c99527788d36d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf22e893c713890faeb9fa8784760b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga0cf22e893c713890faeb9fa8784760b1">atcab_aes_cmac_update</a> (<a class="el" href="a00916.html#ga05fa8c58bf4408381db8871b0dca64b6">atca_aes_cmac_ctx_t</a> *ctx, const uint8_t *data, uint32_t data_size)</td></tr>
<tr class="memdesc:ga0cf22e893c713890faeb9fa8784760b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to an initialized CMAC calculation.  <a href="#ga0cf22e893c713890faeb9fa8784760b1">More...</a><br /></td></tr>
<tr class="separator:ga0cf22e893c713890faeb9fa8784760b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0be51b283b107465dcf42758ca31687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gac0be51b283b107465dcf42758ca31687">atcab_aes_cmac_finish</a> (<a class="el" href="a00916.html#ga05fa8c58bf4408381db8871b0dca64b6">atca_aes_cmac_ctx_t</a> *ctx, uint8_t *cmac, uint32_t cmac_size)</td></tr>
<tr class="memdesc:gac0be51b283b107465dcf42758ca31687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish a CMAC operation returning the CMAC value.  <a href="#gac0be51b283b107465dcf42758ca31687">More...</a><br /></td></tr>
<tr class="separator:gac0be51b283b107465dcf42758ca31687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0db7d24f31dc2dd4805e3c433ae604ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga0db7d24f31dc2dd4805e3c433ae604ad">atcab_aes_ctr_init</a> (<a class="el" href="a00916.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *ctx, uint16_t key_id, uint8_t key_block, uint8_t counter_size, const uint8_t *iv)</td></tr>
<tr class="memdesc:ga0db7d24f31dc2dd4805e3c433ae604ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize context for AES CTR operation with an existing IV, which is common when start a decrypt operation.  <a href="#ga0db7d24f31dc2dd4805e3c433ae604ad">More...</a><br /></td></tr>
<tr class="separator:ga0db7d24f31dc2dd4805e3c433ae604ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7558905ea6a82c4bd50d4b99e954d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gae7558905ea6a82c4bd50d4b99e954d91">atcab_aes_ctr_init_rand</a> (<a class="el" href="a00916.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *ctx, uint16_t key_id, uint8_t key_block, uint8_t counter_size, uint8_t *iv)</td></tr>
<tr class="memdesc:gae7558905ea6a82c4bd50d4b99e954d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize context for AES CTR operation with a random nonce and counter set to 0 as the IV, which is common when starting an encrypt operation.  <a href="#gae7558905ea6a82c4bd50d4b99e954d91">More...</a><br /></td></tr>
<tr class="separator:gae7558905ea6a82c4bd50d4b99e954d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76937b340e59be4dc1a30d8c7b76ebe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga76937b340e59be4dc1a30d8c7b76ebe0">atcab_aes_ctr_block</a> (<a class="el" href="a00916.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *ctx, const uint8_t *input, uint8_t *output)</td></tr>
<tr class="memdesc:ga76937b340e59be4dc1a30d8c7b76ebe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a block of data using CTR mode and a key within the ATECC608A device. <a class="el" href="a00916.html#ga0db7d24f31dc2dd4805e3c433ae604ad" title="Initialize context for AES CTR operation with an existing IV, which is common when start a decrypt op...">atcab_aes_ctr_init()</a> or <a class="el" href="a00916.html#gae7558905ea6a82c4bd50d4b99e954d91" title="Initialize context for AES CTR operation with a random nonce and counter set to 0 as the IV...">atcab_aes_ctr_init_rand()</a> should be called before the first use of this function.  <a href="#ga76937b340e59be4dc1a30d8c7b76ebe0">More...</a><br /></td></tr>
<tr class="separator:ga76937b340e59be4dc1a30d8c7b76ebe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7182e48a847f9c1b31f19c60f373e2da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga7182e48a847f9c1b31f19c60f373e2da">atcab_aes_ctr_encrypt_block</a> (<a class="el" href="a00916.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *ctx, const uint8_t *plaintext, uint8_t *ciphertext)</td></tr>
<tr class="memdesc:ga7182e48a847f9c1b31f19c60f373e2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt a block of data using CTR mode and a key within the ATECC608A device. <a class="el" href="a00916.html#ga0db7d24f31dc2dd4805e3c433ae604ad" title="Initialize context for AES CTR operation with an existing IV, which is common when start a decrypt op...">atcab_aes_ctr_init()</a> or <a class="el" href="a00916.html#gae7558905ea6a82c4bd50d4b99e954d91" title="Initialize context for AES CTR operation with a random nonce and counter set to 0 as the IV...">atcab_aes_ctr_init_rand()</a> should be called before the first use of this function.  <a href="#ga7182e48a847f9c1b31f19c60f373e2da">More...</a><br /></td></tr>
<tr class="separator:ga7182e48a847f9c1b31f19c60f373e2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada9491be0c81fb18b021f71b9a6eda3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gada9491be0c81fb18b021f71b9a6eda3e">atcab_aes_ctr_decrypt_block</a> (<a class="el" href="a00916.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *ctx, const uint8_t *ciphertext, uint8_t *plaintext)</td></tr>
<tr class="memdesc:gada9491be0c81fb18b021f71b9a6eda3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt a block of data using CTR mode and a key within the ATECC608A device. <a class="el" href="a00916.html#ga0db7d24f31dc2dd4805e3c433ae604ad" title="Initialize context for AES CTR operation with an existing IV, which is common when start a decrypt op...">atcab_aes_ctr_init()</a> or <a class="el" href="a00916.html#gae7558905ea6a82c4bd50d4b99e954d91" title="Initialize context for AES CTR operation with a random nonce and counter set to 0 as the IV...">atcab_aes_ctr_init_rand()</a> should be called before the first use of this function.  <a href="#gada9491be0c81fb18b021f71b9a6eda3e">More...</a><br /></td></tr>
<tr class="separator:gada9491be0c81fb18b021f71b9a6eda3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga475b72450dcd21c822de5cb366197927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga475b72450dcd21c822de5cb366197927">atcab_aes_ctr_increment</a> (<a class="el" href="a00916.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *ctx)</td></tr>
<tr class="memdesc:ga475b72450dcd21c822de5cb366197927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments AES CTR counter value.  <a href="#ga475b72450dcd21c822de5cb366197927">More...</a><br /></td></tr>
<tr class="separator:ga475b72450dcd21c822de5cb366197927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga5ba49c05f7b3fb5acaf55df993ccd3ee">atcab_checkmac</a> (uint8_t mode, uint16_t key_id, const uint8_t *challenge, const uint8_t *response, const uint8_t *other_data)</td></tr>
<tr class="memdesc:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a MAC response with input values.  <a href="#ga5ba49c05f7b3fb5acaf55df993ccd3ee">More...</a><br /></td></tr>
<tr class="separator:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaaaef242649206029e1c10ac6d1fb7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gabaaaef242649206029e1c10ac6d1fb7d">atcab_counter</a> (uint8_t mode, uint16_t counter_id, uint32_t *counter_value)</td></tr>
<tr class="memdesc:gabaaaef242649206029e1c10ac6d1fb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Counter functions.  <a href="#gabaaaef242649206029e1c10ac6d1fb7d">More...</a><br /></td></tr>
<tr class="separator:gabaaaef242649206029e1c10ac6d1fb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e510e056ea16a0a34b405b7ca378f16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga6e510e056ea16a0a34b405b7ca378f16">atcab_counter_increment</a> (uint16_t counter_id, uint32_t *counter_value)</td></tr>
<tr class="memdesc:ga6e510e056ea16a0a34b405b7ca378f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments one of the device's monotonic counters.  <a href="#ga6e510e056ea16a0a34b405b7ca378f16">More...</a><br /></td></tr>
<tr class="separator:ga6e510e056ea16a0a34b405b7ca378f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeee666028a097659af69cc828a6bd68b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gaeee666028a097659af69cc828a6bd68b">atcab_counter_read</a> (uint16_t counter_id, uint32_t *counter_value)</td></tr>
<tr class="memdesc:gaeee666028a097659af69cc828a6bd68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one of the device's monotonic counters.  <a href="#gaeee666028a097659af69cc828a6bd68b">More...</a><br /></td></tr>
<tr class="separator:gaeee666028a097659af69cc828a6bd68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34b7b6d46868f0d63d195216ef9939b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga34b7b6d46868f0d63d195216ef9939b1">atcab_derivekey</a> (uint8_t mode, uint16_t key_id, const uint8_t *mac)</td></tr>
<tr class="memdesc:ga34b7b6d46868f0d63d195216ef9939b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the DeviveKey command for deriving a new key from a nonce (TempKey) and an existing key.  <a href="#ga34b7b6d46868f0d63d195216ef9939b1">More...</a><br /></td></tr>
<tr class="separator:ga34b7b6d46868f0d63d195216ef9939b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211c9405bb5049dd4a5da92d25c83f3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga211c9405bb5049dd4a5da92d25c83f3c">atcab_ecdh_base</a> (uint8_t mode, uint16_t key_id, const uint8_t *public_key, uint8_t *pms, uint8_t *out_nonce)</td></tr>
<tr class="memdesc:ga211c9405bb5049dd4a5da92d25c83f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base function for generating premaster secret key using ECDH.  <a href="#ga211c9405bb5049dd4a5da92d25c83f3c">More...</a><br /></td></tr>
<tr class="separator:ga211c9405bb5049dd4a5da92d25c83f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fc480ad2824df6309f4f370ffad15f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga6fc480ad2824df6309f4f370ffad15f9">atcab_ecdh</a> (uint16_t key_id, const uint8_t *public_key, uint8_t *pms)</td></tr>
<tr class="memdesc:ga6fc480ad2824df6309f4f370ffad15f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in a slot and the premaster secret is returned in the clear.  <a href="#ga6fc480ad2824df6309f4f370ffad15f9">More...</a><br /></td></tr>
<tr class="separator:ga6fc480ad2824df6309f4f370ffad15f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6e0c175cbcb5f794b12a8ec22485176"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gab6e0c175cbcb5f794b12a8ec22485176">atcab_ecdh_enc</a> (uint16_t key_id, const uint8_t *public_key, uint8_t *pms, const uint8_t *read_key, uint16_t read_key_id)</td></tr>
<tr class="memdesc:gab6e0c175cbcb5f794b12a8ec22485176"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in a slot and the premaster secret is read from the next slot.  <a href="#gab6e0c175cbcb5f794b12a8ec22485176">More...</a><br /></td></tr>
<tr class="separator:gab6e0c175cbcb5f794b12a8ec22485176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga975f7303086190d3b6f76c367583d622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga975f7303086190d3b6f76c367583d622">atcab_ecdh_ioenc</a> (uint16_t key_id, const uint8_t *public_key, uint8_t *pms, const uint8_t *io_key)</td></tr>
<tr class="memdesc:ga975f7303086190d3b6f76c367583d622"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in a slot and the premaster secret is returned encrypted using the IO protection key.  <a href="#ga975f7303086190d3b6f76c367583d622">More...</a><br /></td></tr>
<tr class="separator:ga975f7303086190d3b6f76c367583d622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac244b83b061ffd8ae3d59b5f973baa53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gac244b83b061ffd8ae3d59b5f973baa53">atcab_ecdh_tempkey</a> (const uint8_t *public_key, uint8_t *pms)</td></tr>
<tr class="memdesc:gac244b83b061ffd8ae3d59b5f973baa53"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in TempKey and the premaster secret is returned in the clear.  <a href="#gac244b83b061ffd8ae3d59b5f973baa53">More...</a><br /></td></tr>
<tr class="separator:gac244b83b061ffd8ae3d59b5f973baa53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaccb0c9d12154b0c5b917f89f233721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gafaccb0c9d12154b0c5b917f89f233721">atcab_ecdh_tempkey_ioenc</a> (const uint8_t *public_key, uint8_t *pms, const uint8_t *io_key)</td></tr>
<tr class="memdesc:gafaccb0c9d12154b0c5b917f89f233721"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in TempKey and the premaster secret is returned encrypted using the IO protection key.  <a href="#gafaccb0c9d12154b0c5b917f89f233721">More...</a><br /></td></tr>
<tr class="separator:gafaccb0c9d12154b0c5b917f89f233721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70751ea87f2cf913986bc7bca2cc661f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga70751ea87f2cf913986bc7bca2cc661f">atcab_gendig</a> (uint8_t zone, uint16_t key_id, const uint8_t *other_data, uint8_t other_data_size)</td></tr>
<tr class="memdesc:ga70751ea87f2cf913986bc7bca2cc661f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a GenDig command, which performs a SHA256 hash on the source data indicated by zone with the contents of TempKey. See the CryptoAuth datasheet for your chip to see what the values of zone correspond to.  <a href="#ga70751ea87f2cf913986bc7bca2cc661f">More...</a><br /></td></tr>
<tr class="separator:ga70751ea87f2cf913986bc7bca2cc661f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gaa8b6953ad2c7f749e61566fd38fe6903">atcab_genkey_base</a> (uint8_t mode, uint16_t key_id, const uint8_t *other_data, uint8_t *public_key)</td></tr>
<tr class="memdesc:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues GenKey command, which can generate a private key, compute a public key, nd/or compute a digest of a public key.  <a href="#gaa8b6953ad2c7f749e61566fd38fe6903">More...</a><br /></td></tr>
<tr class="separator:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga617bdbdce7b5736351d93214d44c5b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga617bdbdce7b5736351d93214d44c5b8f">atcab_genkey</a> (uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga617bdbdce7b5736351d93214d44c5b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues GenKey command, which generates a new random private key in slot and returns the public key.  <a href="#ga617bdbdce7b5736351d93214d44c5b8f">More...</a><br /></td></tr>
<tr class="separator:ga617bdbdce7b5736351d93214d44c5b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2096a4618dd37c48ed48847fe63d844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gad2096a4618dd37c48ed48847fe63d844">atcab_get_pubkey</a> (uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:gad2096a4618dd37c48ed48847fe63d844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses GenKey command to calculate the public key from an existing private key in a slot.  <a href="#gad2096a4618dd37c48ed48847fe63d844">More...</a><br /></td></tr>
<tr class="separator:gad2096a4618dd37c48ed48847fe63d844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga45f1d09a51f7a1f68916536ab5125b9d">atcab_hmac</a> (uint8_t mode, uint16_t key_id, uint8_t *digest)</td></tr>
<tr class="memdesc:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a HMAC command, which computes an HMAC/SHA-256 digest of a key stored in the device, a challenge, and other information on the device.  <a href="#ga45f1d09a51f7a1f68916536ab5125b9d">More...</a><br /></td></tr>
<tr class="separator:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga806d07982fda5c30755af6b5b4ef9314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga806d07982fda5c30755af6b5b4ef9314">atcab_info_base</a> (uint8_t mode, uint16_t param2, uint8_t *out_data)</td></tr>
<tr class="memdesc:ga806d07982fda5c30755af6b5b4ef9314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues an Info command, which return internal device information and can control GPIO and the persistent latch.  <a href="#ga806d07982fda5c30755af6b5b4ef9314">More...</a><br /></td></tr>
<tr class="separator:ga806d07982fda5c30755af6b5b4ef9314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e19ecd60be4c74665d9ec142e460771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga6e19ecd60be4c74665d9ec142e460771">atcab_info</a> (uint8_t *revision)</td></tr>
<tr class="memdesc:ga6e19ecd60be4c74665d9ec142e460771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to get the device revision (DevRev).  <a href="#ga6e19ecd60be4c74665d9ec142e460771">More...</a><br /></td></tr>
<tr class="separator:ga6e19ecd60be4c74665d9ec142e460771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2649126606db8a0b64ae8e19d09f6600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga2649126606db8a0b64ae8e19d09f6600">atcab_info_set_latch</a> (bool state)</td></tr>
<tr class="memdesc:ga2649126606db8a0b64ae8e19d09f6600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to set the persistent latch state for an ATECC608A device.  <a href="#ga2649126606db8a0b64ae8e19d09f6600">More...</a><br /></td></tr>
<tr class="separator:ga2649126606db8a0b64ae8e19d09f6600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga376b6ae92f14c60fba4ca5c6461e0b48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga376b6ae92f14c60fba4ca5c6461e0b48">atcab_info_get_latch</a> (bool *state)</td></tr>
<tr class="memdesc:ga376b6ae92f14c60fba4ca5c6461e0b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to get the persistent latch current state for an ATECC608A device.  <a href="#ga376b6ae92f14c60fba4ca5c6461e0b48">More...</a><br /></td></tr>
<tr class="separator:ga376b6ae92f14c60fba4ca5c6461e0b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40a6c01492a76366f9402302b527c4e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga40a6c01492a76366f9402302b527c4e1">atcab_kdf</a> (uint8_t mode, uint16_t key_id, const uint32_t details, const uint8_t *message, uint8_t *out_data, uint8_t *out_nonce)</td></tr>
<tr class="memdesc:ga40a6c01492a76366f9402302b527c4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the KDF command, which derives a new key in PRF, AES, or HKDF modes.  <a href="#ga40a6c01492a76366f9402302b527c4e1">More...</a><br /></td></tr>
<tr class="separator:ga40a6c01492a76366f9402302b527c4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d2895192d93c524f5dba92a492cdfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga25d2895192d93c524f5dba92a492cdfb">atcab_lock</a> (uint8_t mode, uint16_t summary_crc)</td></tr>
<tr class="memdesc:ga25d2895192d93c524f5dba92a492cdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Lock command prevents future modifications of the Configuration and/or Data and OTP zones. If the device is so configured, then this command can be used to lock individual data slots. This command fails if the designated area is already locked.  <a href="#ga25d2895192d93c524f5dba92a492cdfb">More...</a><br /></td></tr>
<tr class="separator:ga25d2895192d93c524f5dba92a492cdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga7cd67c03c7184ad041e2c0ad4f27db23">atcab_lock_config_zone</a> (void)</td></tr>
<tr class="memdesc:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the config zone.  <a href="#ga7cd67c03c7184ad041e2c0ad4f27db23">More...</a><br /></td></tr>
<tr class="separator:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0698e0c55ad700fe57498321e842cb38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga0698e0c55ad700fe57498321e842cb38">atcab_lock_config_zone_crc</a> (uint16_t summary_crc)</td></tr>
<tr class="memdesc:ga0698e0c55ad700fe57498321e842cb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the config zone with summary CRC.  <a href="#ga0698e0c55ad700fe57498321e842cb38">More...</a><br /></td></tr>
<tr class="separator:ga0698e0c55ad700fe57498321e842cb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8020aa89a5bed09ad35320b78e0fb890"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga8020aa89a5bed09ad35320b78e0fb890">atcab_lock_data_zone</a> (void)</td></tr>
<tr class="memdesc:ga8020aa89a5bed09ad35320b78e0fb890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the data zone (slots and OTP).  <a href="#ga8020aa89a5bed09ad35320b78e0fb890">More...</a><br /></td></tr>
<tr class="separator:ga8020aa89a5bed09ad35320b78e0fb890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf29e398e2aca927ab4606aa1ec0308c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gaf29e398e2aca927ab4606aa1ec0308c6">atcab_lock_data_zone_crc</a> (uint16_t summary_crc)</td></tr>
<tr class="memdesc:gaf29e398e2aca927ab4606aa1ec0308c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the data zone (slots and OTP) with summary CRC.  <a href="#gaf29e398e2aca927ab4606aa1ec0308c6">More...</a><br /></td></tr>
<tr class="separator:gaf29e398e2aca927ab4606aa1ec0308c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga958190a9182d1b54f82fbca8216406ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga958190a9182d1b54f82fbca8216406ea">atcab_lock_data_slot</a> (uint16_t slot)</td></tr>
<tr class="memdesc:ga958190a9182d1b54f82fbca8216406ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock an individual slot in the data zone on an ATECC device. Not available for ATSHA devices. Slot must be configured to be slot lockable (KeyConfig.Lockable=1).  <a href="#ga958190a9182d1b54f82fbca8216406ea">More...</a><br /></td></tr>
<tr class="separator:ga958190a9182d1b54f82fbca8216406ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga98cb802fbb5d78cd552bb05c21d6c791">atcab_mac</a> (uint8_t mode, uint16_t key_id, const uint8_t *challenge, uint8_t *digest)</td></tr>
<tr class="memdesc:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes MAC command, which computes a SHA-256 digest of a key stored in the device, a challenge, and other information on the device.  <a href="#ga98cb802fbb5d78cd552bb05c21d6c791">More...</a><br /></td></tr>
<tr class="separator:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8e10791759a8a5e5dcd82774f4895d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gaf8e10791759a8a5e5dcd82774f4895d6">atcab_nonce_base</a> (uint8_t mode, uint16_t zero, const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaf8e10791759a8a5e5dcd82774f4895d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Nonce command, which loads a random or fixed nonce/data into the device for use by subsequent commands.  <a href="#gaf8e10791759a8a5e5dcd82774f4895d6">More...</a><br /></td></tr>
<tr class="separator:gaf8e10791759a8a5e5dcd82774f4895d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2293df1c1c794496790bae25d3844fa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga2293df1c1c794496790bae25d3844fa5">atcab_nonce</a> (const uint8_t *num_in)</td></tr>
<tr class="memdesc:ga2293df1c1c794496790bae25d3844fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command in pass-through mode to initialize TempKey to a specified value.  <a href="#ga2293df1c1c794496790bae25d3844fa5">More...</a><br /></td></tr>
<tr class="separator:ga2293df1c1c794496790bae25d3844fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2239ae3a87c341a48aa108bd82a58552"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga2239ae3a87c341a48aa108bd82a58552">atcab_nonce_load</a> (uint8_t target, const uint8_t *num_in, uint16_t num_in_size)</td></tr>
<tr class="memdesc:ga2239ae3a87c341a48aa108bd82a58552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command in pass-through mode to load one of the device's internal buffers with a fixed value.  <a href="#ga2239ae3a87c341a48aa108bd82a58552">More...</a><br /></td></tr>
<tr class="separator:ga2239ae3a87c341a48aa108bd82a58552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed67d447d547c67b7b8be6b958d1fb5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gaed67d447d547c67b7b8be6b958d1fb5c">atcab_nonce_rand</a> (const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaed67d447d547c67b7b8be6b958d1fb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command to generate a random nonce combining a host nonce (num_in) and a device random number.  <a href="#gaed67d447d547c67b7b8be6b958d1fb5c">More...</a><br /></td></tr>
<tr class="separator:gaed67d447d547c67b7b8be6b958d1fb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga114a721517c95d5ba5fcac5b226669d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga114a721517c95d5ba5fcac5b226669d6">atcab_challenge</a> (const uint8_t *num_in)</td></tr>
<tr class="memdesc:ga114a721517c95d5ba5fcac5b226669d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command in pass-through mode to initialize TempKey to a specified value.  <a href="#ga114a721517c95d5ba5fcac5b226669d6">More...</a><br /></td></tr>
<tr class="separator:ga114a721517c95d5ba5fcac5b226669d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadde4309089c569fd87c24a1a2326cd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gaadde4309089c569fd87c24a1a2326cd4">atcab_challenge_seed_update</a> (const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaadde4309089c569fd87c24a1a2326cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command to generate a random challenge combining a host nonce (num_in) and a device random number.  <a href="#gaadde4309089c569fd87c24a1a2326cd4">More...</a><br /></td></tr>
<tr class="separator:gaadde4309089c569fd87c24a1a2326cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad01e8e785073d8655de9116e7df8e7b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gad01e8e785073d8655de9116e7df8e7b5">atcab_priv_write</a> (uint16_t key_id, const uint8_t priv_key[36], uint16_t write_key_id, const uint8_t write_key[32])</td></tr>
<tr class="memdesc:gad01e8e785073d8655de9116e7df8e7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes PrivWrite command, to write externally generated ECC private keys into the device.  <a href="#gad01e8e785073d8655de9116e7df8e7b5">More...</a><br /></td></tr>
<tr class="separator:gad01e8e785073d8655de9116e7df8e7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fa442396dfbb89e59dfca837b565cec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga4fa442396dfbb89e59dfca837b565cec">atcab_random</a> (uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga4fa442396dfbb89e59dfca837b565cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Random command, which generates a 32 byte random number from the CryptoAuth device.  <a href="#ga4fa442396dfbb89e59dfca837b565cec">More...</a><br /></td></tr>
<tr class="separator:ga4fa442396dfbb89e59dfca837b565cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga3ce01f02f456c08891ca1d67cd3ed0eb">atcab_read_zone</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command, which reads either 4 or 32 bytes of data from a given slot, configuration zone, or the OTP zone.  <a href="#ga3ce01f02f456c08891ca1d67cd3ed0eb">More...</a><br /></td></tr>
<tr class="separator:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefce484222bdbedef37787a9b10d4426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gaefce484222bdbedef37787a9b10d4426">atcab_is_locked</a> (uint8_t zone, bool *is_locked)</td></tr>
<tr class="memdesc:gaefce484222bdbedef37787a9b10d4426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command, which reads the configuration zone to see if the specified zone is locked.  <a href="#gaefce484222bdbedef37787a9b10d4426">More...</a><br /></td></tr>
<tr class="separator:gaefce484222bdbedef37787a9b10d4426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga802de50265ff91dc30dd7c93d9e026e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga802de50265ff91dc30dd7c93d9e026e1">atcab_is_slot_locked</a> (uint16_t slot, bool *is_locked)</td></tr>
<tr class="memdesc:ga802de50265ff91dc30dd7c93d9e026e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command, which reads the configuration zone to see if the specified slot is locked.  <a href="#ga802de50265ff91dc30dd7c93d9e026e1">More...</a><br /></td></tr>
<tr class="separator:ga802de50265ff91dc30dd7c93d9e026e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga750704332198726725a327344f4f7dd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga750704332198726725a327344f4f7dd5">atcab_read_bytes_zone</a> (uint8_t zone, uint16_t slot, size_t offset, uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:ga750704332198726725a327344f4f7dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to read an arbitrary number of bytes from any zone configured for clear reads.  <a href="#ga750704332198726725a327344f4f7dd5">More...</a><br /></td></tr>
<tr class="separator:ga750704332198726725a327344f4f7dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96c434878e1f435e2cda5b0b5fec444f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga96c434878e1f435e2cda5b0b5fec444f">atcab_read_serial_number</a> (uint8_t *serial_number)</td></tr>
<tr class="memdesc:ga96c434878e1f435e2cda5b0b5fec444f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command, which reads the 9 byte serial number of the device from the config zone.  <a href="#ga96c434878e1f435e2cda5b0b5fec444f">More...</a><br /></td></tr>
<tr class="separator:ga96c434878e1f435e2cda5b0b5fec444f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga782ca1e5b1574b2b6793c841be22b28b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga782ca1e5b1574b2b6793c841be22b28b">atcab_read_pubkey</a> (uint16_t slot, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga782ca1e5b1574b2b6793c841be22b28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read an ECC P256 public key from a slot configured for clear reads.  <a href="#ga782ca1e5b1574b2b6793c841be22b28b">More...</a><br /></td></tr>
<tr class="separator:ga782ca1e5b1574b2b6793c841be22b28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga098c4c2c724b90b7e2f4ecf12b9530b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga098c4c2c724b90b7e2f4ecf12b9530b7">atcab_read_sig</a> (uint16_t slot, uint8_t *sig)</td></tr>
<tr class="memdesc:ga098c4c2c724b90b7e2f4ecf12b9530b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read a 64 byte ECDSA P256 signature from a slot configured for clear reads.  <a href="#ga098c4c2c724b90b7e2f4ecf12b9530b7">More...</a><br /></td></tr>
<tr class="separator:ga098c4c2c724b90b7e2f4ecf12b9530b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga8ef47330eef6bc72ae8f7a8ef026dae3">atcab_read_config_zone</a> (uint8_t *config_data)</td></tr>
<tr class="memdesc:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read the complete device configuration zone.  <a href="#ga8ef47330eef6bc72ae8f7a8ef026dae3">More...</a><br /></td></tr>
<tr class="separator:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gadb91d2c3601b95f0ad413cf84a4dfd87">atcab_cmp_config_zone</a> (uint8_t *config_data, bool *same_config)</td></tr>
<tr class="memdesc:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a specified configuration zone with the configuration zone currently on the device.  <a href="#gadb91d2c3601b95f0ad413cf84a4dfd87">More...</a><br /></td></tr>
<tr class="separator:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga778a262b86fa1f8a38139cbae34376e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga778a262b86fa1f8a38139cbae34376e4">atcab_read_enc</a> (uint16_t key_id, uint8_t block, uint8_t *data, const uint8_t *enc_key, const uint16_t enc_key_id)</td></tr>
<tr class="memdesc:ga778a262b86fa1f8a38139cbae34376e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command on a slot configured for encrypted reads and decrypts the data to return it as plaintext.  <a href="#ga778a262b86fa1f8a38139cbae34376e4">More...</a><br /></td></tr>
<tr class="separator:ga778a262b86fa1f8a38139cbae34376e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9506331ea7d454fe3c9b2585128c77aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga9506331ea7d454fe3c9b2585128c77aa">atcab_secureboot</a> (uint8_t mode, uint16_t param2, const uint8_t *digest, const uint8_t *signature, uint8_t *mac)</td></tr>
<tr class="memdesc:ga9506331ea7d454fe3c9b2585128c77aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Secure Boot command, which provides support for secure boot of an external MCU or MPU.  <a href="#ga9506331ea7d454fe3c9b2585128c77aa">More...</a><br /></td></tr>
<tr class="separator:ga9506331ea7d454fe3c9b2585128c77aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c11f2012a03ec79cb46de8e03ed0534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga5c11f2012a03ec79cb46de8e03ed0534">atcab_secureboot_mac</a> (uint8_t mode, const uint8_t *digest, const uint8_t *signature, const uint8_t *num_in, const uint8_t *io_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga5c11f2012a03ec79cb46de8e03ed0534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Secure Boot command with encrypted digest and validated MAC response using the IO protection key.  <a href="#ga5c11f2012a03ec79cb46de8e03ed0534">More...</a><br /></td></tr>
<tr class="separator:ga5c11f2012a03ec79cb46de8e03ed0534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb4a36bc6992612cc3b1f950c0d020b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gaeb4a36bc6992612cc3b1f950c0d020b7">atcab_selftest</a> (uint8_t mode, uint16_t param2, uint8_t *result)</td></tr>
<tr class="memdesc:gaeb4a36bc6992612cc3b1f950c0d020b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the SelfTest command, which performs a test of one or more of the cryptographic engines within the ATECC608A chip.  <a href="#gaeb4a36bc6992612cc3b1f950c0d020b7">More...</a><br /></td></tr>
<tr class="separator:gaeb4a36bc6992612cc3b1f950c0d020b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a32e171ca1c30bd31a216b32c9b5a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gab3a32e171ca1c30bd31a216b32c9b5a4">atcab_sha_base</a> (uint8_t mode, uint16_t length, const uint8_t *data_in, uint8_t *data_out, uint16_t *data_out_size)</td></tr>
<tr class="memdesc:gab3a32e171ca1c30bd31a216b32c9b5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command, which computes a SHA-256 or HMAC/SHA-256 digest for general purpose use by the host system.  <a href="#gab3a32e171ca1c30bd31a216b32c9b5a4">More...</a><br /></td></tr>
<tr class="separator:gab3a32e171ca1c30bd31a216b32c9b5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gae0a7ef89fce4cbd0ee1c76759cd93b9a">atcab_sha_start</a> (void)</td></tr>
<tr class="memdesc:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to initialize SHA-256 calculation engine.  <a href="#gae0a7ef89fce4cbd0ee1c76759cd93b9a">More...</a><br /></td></tr>
<tr class="separator:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga39bd70baa7a4c7f4849fcf8b94d4d949">atcab_sha_update</a> (const uint8_t *message)</td></tr>
<tr class="memdesc:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to add 64 bytes of message data to the current context.  <a href="#ga39bd70baa7a4c7f4849fcf8b94d4d949">More...</a><br /></td></tr>
<tr class="separator:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db86704035048066a370815b657234d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga1db86704035048066a370815b657234d">atcab_sha_end</a> (uint8_t *digest, uint16_t length, const uint8_t *message)</td></tr>
<tr class="memdesc:ga1db86704035048066a370815b657234d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to complete SHA-256 or HMAC/SHA-256 operation.  <a href="#ga1db86704035048066a370815b657234d">More...</a><br /></td></tr>
<tr class="separator:ga1db86704035048066a370815b657234d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d1db50562642ce511fa7cbd384c2ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga74d1db50562642ce511fa7cbd384c2ab">atcab_sha_read_context</a> (uint8_t *context, uint16_t *context_size)</td></tr>
<tr class="memdesc:ga74d1db50562642ce511fa7cbd384c2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to read the SHA-256 context back. Only for ATECC608A with SHA-256 contexts. HMAC not supported.  <a href="#ga74d1db50562642ce511fa7cbd384c2ab">More...</a><br /></td></tr>
<tr class="separator:ga74d1db50562642ce511fa7cbd384c2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga070fa80ac0d76f6816d9f7affbcfb120"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga070fa80ac0d76f6816d9f7affbcfb120">atcab_sha_write_context</a> (const uint8_t *context, uint16_t context_size)</td></tr>
<tr class="memdesc:ga070fa80ac0d76f6816d9f7affbcfb120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to write (restore) a SHA-256 context into the the device. Only supported for ATECC608A with SHA-256 contexts.  <a href="#ga070fa80ac0d76f6816d9f7affbcfb120">More...</a><br /></td></tr>
<tr class="separator:ga070fa80ac0d76f6816d9f7affbcfb120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d269ccdafd08519a899a8aebf53df1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga31d269ccdafd08519a899a8aebf53df1">atcab_sha</a> (uint16_t length, const uint8_t *message, uint8_t *digest)</td></tr>
<tr class="memdesc:ga31d269ccdafd08519a899a8aebf53df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SHA command to compute a SHA-256 digest.  <a href="#ga31d269ccdafd08519a899a8aebf53df1">More...</a><br /></td></tr>
<tr class="separator:ga31d269ccdafd08519a899a8aebf53df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf8b665fe1712626a480742c2daa16b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga4bf8b665fe1712626a480742c2daa16b">atcab_hw_sha2_256</a> (const uint8_t *data, size_t data_size, uint8_t *digest)</td></tr>
<tr class="memdesc:ga4bf8b665fe1712626a480742c2daa16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SHA command to compute a SHA-256 digest.  <a href="#ga4bf8b665fe1712626a480742c2daa16b">More...</a><br /></td></tr>
<tr class="separator:ga4bf8b665fe1712626a480742c2daa16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade49e7746864105730fa7d531645ff62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gade49e7746864105730fa7d531645ff62">atcab_hw_sha2_256_init</a> (<a class="el" href="a00916.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *ctx)</td></tr>
<tr class="memdesc:gade49e7746864105730fa7d531645ff62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a SHA context for performing a hardware SHA-256 operation on a device. Note that only one SHA operation can be run at a time.  <a href="#gade49e7746864105730fa7d531645ff62">More...</a><br /></td></tr>
<tr class="separator:gade49e7746864105730fa7d531645ff62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67f2ce6224651d9cc65e9915e35558bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga67f2ce6224651d9cc65e9915e35558bd">atcab_hw_sha2_256_update</a> (<a class="el" href="a00916.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *ctx, const uint8_t *data, size_t data_size)</td></tr>
<tr class="memdesc:ga67f2ce6224651d9cc65e9915e35558bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add message data to a SHA context for performing a hardware SHA-256 operation on a device.  <a href="#ga67f2ce6224651d9cc65e9915e35558bd">More...</a><br /></td></tr>
<tr class="separator:ga67f2ce6224651d9cc65e9915e35558bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed7e645262fcc32b00d8a9facf09e91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga6ed7e645262fcc32b00d8a9facf09e91">atcab_hw_sha2_256_finish</a> (<a class="el" href="a00916.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *ctx, uint8_t *digest)</td></tr>
<tr class="memdesc:ga6ed7e645262fcc32b00d8a9facf09e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish SHA-256 digest for a SHA context for performing a hardware SHA-256 operation on a device.  <a href="#ga6ed7e645262fcc32b00d8a9facf09e91">More...</a><br /></td></tr>
<tr class="separator:ga6ed7e645262fcc32b00d8a9facf09e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga310a017cddce9ef05071cb619b4b6db9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga310a017cddce9ef05071cb619b4b6db9">atcab_sha_hmac_init</a> (<a class="el" href="a00916.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a> *ctx, uint16_t key_slot)</td></tr>
<tr class="memdesc:ga310a017cddce9ef05071cb619b4b6db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to start an HMAC/SHA-256 operation.  <a href="#ga310a017cddce9ef05071cb619b4b6db9">More...</a><br /></td></tr>
<tr class="separator:ga310a017cddce9ef05071cb619b4b6db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3343c160e80365b7e96bdfdc9b6365c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gae3343c160e80365b7e96bdfdc9b6365c">atcab_sha_hmac_update</a> (<a class="el" href="a00916.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a> *ctx, const uint8_t *data, size_t data_size)</td></tr>
<tr class="memdesc:gae3343c160e80365b7e96bdfdc9b6365c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to add an arbitrary amount of message data to a HMAC/SHA-256 operation.  <a href="#gae3343c160e80365b7e96bdfdc9b6365c">More...</a><br /></td></tr>
<tr class="separator:gae3343c160e80365b7e96bdfdc9b6365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4be9972396b7cadb08dd8e2199daf08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gaa4be9972396b7cadb08dd8e2199daf08">atcab_sha_hmac_finish</a> (<a class="el" href="a00916.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a> *ctx, uint8_t *digest, uint8_t target)</td></tr>
<tr class="memdesc:gaa4be9972396b7cadb08dd8e2199daf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to complete a HMAC/SHA-256 operation.  <a href="#gaa4be9972396b7cadb08dd8e2199daf08">More...</a><br /></td></tr>
<tr class="separator:gaa4be9972396b7cadb08dd8e2199daf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae655ce06583c08169170102fbb0b55c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gae655ce06583c08169170102fbb0b55c9">atcab_sha_hmac</a> (const uint8_t *data, size_t data_size, uint16_t key_slot, uint8_t *digest, uint8_t target)</td></tr>
<tr class="memdesc:gae655ce06583c08169170102fbb0b55c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SHA command to compute an HMAC/SHA-256 operation.  <a href="#gae655ce06583c08169170102fbb0b55c9">More...</a><br /></td></tr>
<tr class="separator:gae655ce06583c08169170102fbb0b55c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga5c1e598bf3d4d25b522f42d6038a4268">atcab_sign_base</a> (uint8_t mode, uint16_t key_id, uint8_t *signature)</td></tr>
<tr class="memdesc:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Sign command, which generates a signature using the ECDSA algorithm.  <a href="#ga5c1e598bf3d4d25b522f42d6038a4268">More...</a><br /></td></tr>
<tr class="separator:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga69b8282d1b1e0c54b9a7d286fed503b8">atcab_sign</a> (uint16_t key_id, const uint8_t *msg, uint8_t *signature)</td></tr>
<tr class="memdesc:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Sign command, to sign a 32-byte external message using the private key in the specified slot. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608A device or TempKey for other devices.  <a href="#ga69b8282d1b1e0c54b9a7d286fed503b8">More...</a><br /></td></tr>
<tr class="separator:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga559add3e8b4f85a9d91fc0ed86aefa29">atcab_sign_internal</a> (uint16_t key_id, bool is_invalidate, bool is_full_sn, uint8_t *signature)</td></tr>
<tr class="memdesc:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Sign command to sign an internally generated message.  <a href="#ga559add3e8b4f85a9d91fc0ed86aefa29">More...</a><br /></td></tr>
<tr class="separator:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga416e4aeacf3acc35b1d5b76028c6947d">atcab_updateextra</a> (uint8_t mode, uint16_t new_value)</td></tr>
<tr class="memdesc:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes UpdateExtra command to update the values of the two extra bytes within the Configuration zone (bytes 84 and 85).  <a href="#ga416e4aeacf3acc35b1d5b76028c6947d">More...</a><br /></td></tr>
<tr class="separator:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694d921c7bc17a0e158ef96e3d476700"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga694d921c7bc17a0e158ef96e3d476700">atcab_verify</a> (uint8_t mode, uint16_t key_id, const uint8_t *signature, const uint8_t *public_key, const uint8_t *other_data, uint8_t *mac)</td></tr>
<tr class="memdesc:ga694d921c7bc17a0e158ef96e3d476700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which takes an ECDSA [R,S] signature and verifies that it is correctly generated from a given message and public key. In all cases, the signature is an input to the command.  <a href="#ga694d921c7bc17a0e158ef96e3d476700">More...</a><br /></td></tr>
<tr class="separator:ga694d921c7bc17a0e158ef96e3d476700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c3e18de900ba705192963d08b37f600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga2c3e18de900ba705192963d08b37f600">atcab_verify_extern</a> (const uint8_t *message, const uint8_t *signature, const uint8_t *public_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga2c3e18de900ba705192963d08b37f600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608A device or TempKey for other devices.  <a href="#ga2c3e18de900ba705192963d08b37f600">More...</a><br /></td></tr>
<tr class="separator:ga2c3e18de900ba705192963d08b37f600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17bf17c4786be097a0bb111a6f9d8ca6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga17bf17c4786be097a0bb111a6f9d8ca6">atcab_verify_extern_mac</a> (const uint8_t *message, const uint8_t *signature, const uint8_t *public_key, const uint8_t *num_in, const uint8_t *io_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga17bf17c4786be097a0bb111a6f9d8ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command with verification MAC, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. This function is only available on the ATECC608A.  <a href="#ga17bf17c4786be097a0bb111a6f9d8ca6">More...</a><br /></td></tr>
<tr class="separator:ga17bf17c4786be097a0bb111a6f9d8ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8cc7670847805423ad591985eecd832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gae8cc7670847805423ad591985eecd832">atcab_verify_stored</a> (const uint8_t *message, const uint8_t *signature, uint16_t key_id, bool *is_verified)</td></tr>
<tr class="memdesc:gae8cc7670847805423ad591985eecd832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which verifies a signature (ECDSA verify operation) with a public key stored in the device. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608A device or TempKey for other devices.  <a href="#gae8cc7670847805423ad591985eecd832">More...</a><br /></td></tr>
<tr class="separator:gae8cc7670847805423ad591985eecd832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52cdbbfd2f089d8eb42ef2640204ca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gaa52cdbbfd2f089d8eb42ef2640204ca7">atcab_verify_stored_mac</a> (const uint8_t *message, const uint8_t *signature, uint16_t key_id, const uint8_t *num_in, const uint8_t *io_key, bool *is_verified)</td></tr>
<tr class="memdesc:gaa52cdbbfd2f089d8eb42ef2640204ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command with verification MAC, which verifies a signature (ECDSA verify operation) with a public key stored in the device. This function is only available on the ATECC608A.  <a href="#gaa52cdbbfd2f089d8eb42ef2640204ca7">More...</a><br /></td></tr>
<tr class="separator:gaa52cdbbfd2f089d8eb42ef2640204ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9a0c7772ebb65b87c4a4788850702b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gacf9a0c7772ebb65b87c4a4788850702b">atcab_verify_validate</a> (uint16_t key_id, const uint8_t *signature, const uint8_t *other_data, bool *is_verified)</td></tr>
<tr class="memdesc:gacf9a0c7772ebb65b87c4a4788850702b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command in Validate mode to validate a public key stored in a slot.  <a href="#gacf9a0c7772ebb65b87c4a4788850702b">More...</a><br /></td></tr>
<tr class="separator:gacf9a0c7772ebb65b87c4a4788850702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9393b545b2fa1fdd539672a0428a30ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga9393b545b2fa1fdd539672a0428a30ab">atcab_verify_invalidate</a> (uint16_t key_id, const uint8_t *signature, const uint8_t *other_data, bool *is_verified)</td></tr>
<tr class="memdesc:ga9393b545b2fa1fdd539672a0428a30ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command in Invalidate mode which invalidates a previously validated public key stored in a slot.  <a href="#ga9393b545b2fa1fdd539672a0428a30ab">More...</a><br /></td></tr>
<tr class="separator:ga9393b545b2fa1fdd539672a0428a30ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf2b29b4d3ae926b63c403d084380dbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gabf2b29b4d3ae926b63c403d084380dbe">atcab_write</a> (uint8_t zone, uint16_t address, const uint8_t *value, const uint8_t *mac)</td></tr>
<tr class="memdesc:gabf2b29b4d3ae926b63c403d084380dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes either one four byte word or a 32-byte block to one of the EEPROM zones on the device. Depending upon the value of the WriteConfig byte for this slot, the data may be required to be encrypted by the system prior to being sent to the device. This command cannot be used to write slots configured as ECC private keys.  <a href="#gabf2b29b4d3ae926b63c403d084380dbe">More...</a><br /></td></tr>
<tr class="separator:gabf2b29b4d3ae926b63c403d084380dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga1f5a6bbcf4f840803635fb8951b3a7e2">atcab_write_zone</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, const uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes either 4 or 32 bytes of data into a device zone.  <a href="#ga1f5a6bbcf4f840803635fb8951b3a7e2">More...</a><br /></td></tr>
<tr class="separator:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac395a7e195aa3cf28b48de345755feb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gac395a7e195aa3cf28b48de345755feb0">atcab_write_bytes_zone</a> (uint8_t zone, uint16_t slot, size_t offset_bytes, const uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:gac395a7e195aa3cf28b48de345755feb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes data into the configuration, otp, or data zones with a given byte offset and length. Offset and length must be multiples of a word (4 bytes).  <a href="#gac395a7e195aa3cf28b48de345755feb0">More...</a><br /></td></tr>
<tr class="separator:gac395a7e195aa3cf28b48de345755feb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47cbedeb3c3e9f7cbf2b9433cd60d1aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga47cbedeb3c3e9f7cbf2b9433cd60d1aa">atcab_write_pubkey</a> (uint16_t slot, const uint8_t *public_key)</td></tr>
<tr class="memdesc:ga47cbedeb3c3e9f7cbf2b9433cd60d1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes a public key to a data slot in the device format.  <a href="#ga47cbedeb3c3e9f7cbf2b9433cd60d1aa">More...</a><br /></td></tr>
<tr class="separator:ga47cbedeb3c3e9f7cbf2b9433cd60d1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0777a86aa412a97b19cc72a12c171b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga0777a86aa412a97b19cc72a12c171b94">atcab_write_config_zone</a> (const uint8_t *config_data)</td></tr>
<tr class="memdesc:ga0777a86aa412a97b19cc72a12c171b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes the configuration zone.  <a href="#ga0777a86aa412a97b19cc72a12c171b94">More...</a><br /></td></tr>
<tr class="separator:ga0777a86aa412a97b19cc72a12c171b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14cf75d1be264ac1125087d76ee6344c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga14cf75d1be264ac1125087d76ee6344c">atcab_write_enc</a> (uint16_t key_id, uint8_t block, const uint8_t *data, const uint8_t *enc_key, const uint16_t enc_key_id)</td></tr>
<tr class="memdesc:ga14cf75d1be264ac1125087d76ee6344c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which performs an encrypted write of a 32 byte block into given slot.  <a href="#ga14cf75d1be264ac1125087d76ee6344c">More...</a><br /></td></tr>
<tr class="separator:ga14cf75d1be264ac1125087d76ee6344c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab25ca44957dff1c2df34607738ca3bf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gab25ca44957dff1c2df34607738ca3bf7">atcab_write_config_counter</a> (uint16_t counter_id, uint32_t counter_value)</td></tr>
<tr class="memdesc:gab25ca44957dff1c2df34607738ca3bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize one of the monotonic counters in device with a specific value.  <a href="#gab25ca44957dff1c2df34607738ca3bf7">More...</a><br /></td></tr>
<tr class="separator:gab25ca44957dff1c2df34607738ca3bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72601de415fd0bbc73faa1ddbc52e56e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga72601de415fd0bbc73faa1ddbc52e56e">atcab_printbin</a> (uint8_t *binary, size_t bin_len, bool add_space)</td></tr>
<tr class="separator:ga72601de415fd0bbc73faa1ddbc52e56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae31a9fd8e9deca79aa5fef0292fe5272"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gae31a9fd8e9deca79aa5fef0292fe5272">atcab_bin2hex</a> (const uint8_t *bin, size_t bin_size, char *hex, size_t *hex_size)</td></tr>
<tr class="memdesc:gae31a9fd8e9deca79aa5fef0292fe5272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a binary buffer to a hex string for easy reading.  <a href="#gae31a9fd8e9deca79aa5fef0292fe5272">More...</a><br /></td></tr>
<tr class="separator:gae31a9fd8e9deca79aa5fef0292fe5272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga121d8391484d9e0c8c0e3f6dbac8285c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga121d8391484d9e0c8c0e3f6dbac8285c">atcab_bin2hex_</a> (const uint8_t *bin, size_t bin_size, char *hex, size_t *hex_size, bool is_pretty)</td></tr>
<tr class="memdesc:ga121d8391484d9e0c8c0e3f6dbac8285c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that converts a binary buffer to a hex string suitable for easy reading.  <a href="#ga121d8391484d9e0c8c0e3f6dbac8285c">More...</a><br /></td></tr>
<tr class="separator:ga121d8391484d9e0c8c0e3f6dbac8285c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481179181349c801c16fc1ab698f2f24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga481179181349c801c16fc1ab698f2f24">atcab_hex2bin</a> (const char *ascii_hex, size_t ascii_hex_len, uint8_t *binary, size_t *bin_len)</td></tr>
<tr class="memdesc:ga481179181349c801c16fc1ab698f2f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that converts a hex string to binary buffer.  <a href="#ga481179181349c801c16fc1ab698f2f24">More...</a><br /></td></tr>
<tr class="separator:ga481179181349c801c16fc1ab698f2f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f88c481b376a7be9112ff081c4ad854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga1f88c481b376a7be9112ff081c4ad854">atcab_printbin_sp</a> (uint8_t *binary, size_t bin_len)</td></tr>
<tr class="separator:ga1f88c481b376a7be9112ff081c4ad854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga248355e3b4bcdd5d728f214fc2eb79e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga248355e3b4bcdd5d728f214fc2eb79e4">atcab_printbin_label</a> (const char *label, uint8_t *binary, size_t bin_len)</td></tr>
<tr class="separator:ga248355e3b4bcdd5d728f214fc2eb79e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad017ae33af5a7ea062cea7d54de675a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gad017ae33af5a7ea062cea7d54de675a8">packHex</a> (const char *ascii_hex, size_t ascii_hex_len, char *packed_hex, size_t *packed_len)</td></tr>
<tr class="memdesc:gad017ae33af5a7ea062cea7d54de675a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove white space from a ASCII hex string.  <a href="#gad017ae33af5a7ea062cea7d54de675a8">More...</a><br /></td></tr>
<tr class="separator:gad017ae33af5a7ea062cea7d54de675a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a929bf65cbc777bab7e533a2755cfad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga7a929bf65cbc777bab7e533a2755cfad">isDigit</a> (char c)</td></tr>
<tr class="memdesc:ga7a929bf65cbc777bab7e533a2755cfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a character is an ASCII representation of a digit ((c ge '0') and (c le '9'))  <a href="#ga7a929bf65cbc777bab7e533a2755cfad">More...</a><br /></td></tr>
<tr class="separator:ga7a929bf65cbc777bab7e533a2755cfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3db1b55b966b792e8308a1819933c0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gab3db1b55b966b792e8308a1819933c0e">isWhiteSpace</a> (char c)</td></tr>
<tr class="memdesc:gab3db1b55b966b792e8308a1819933c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a character is whitespace.  <a href="#gab3db1b55b966b792e8308a1819933c0e">More...</a><br /></td></tr>
<tr class="separator:gab3db1b55b966b792e8308a1819933c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga592c23e94097ad5e212beb6390aa88c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga592c23e94097ad5e212beb6390aa88c6">isAlpha</a> (char c)</td></tr>
<tr class="memdesc:ga592c23e94097ad5e212beb6390aa88c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a character is an ASCII representation of hex ((c &gt;= 'A') and (c &lt;= 'F')) || ((c &gt;= 'a') and (c &lt;= 'f'))  <a href="#ga592c23e94097ad5e212beb6390aa88c6">More...</a><br /></td></tr>
<tr class="separator:ga592c23e94097ad5e212beb6390aa88c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78abefc293c0a04d8ef649c94c8a1057"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga78abefc293c0a04d8ef649c94c8a1057">isHexAlpha</a> (char c)</td></tr>
<tr class="memdesc:ga78abefc293c0a04d8ef649c94c8a1057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a character is an ASCII representation of hex ((c &gt;= 'A') and (c &lt;= 'F')) || ((c &gt;= 'a') and (c &lt;= 'f'))  <a href="#ga78abefc293c0a04d8ef649c94c8a1057">More...</a><br /></td></tr>
<tr class="separator:ga78abefc293c0a04d8ef649c94c8a1057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7ca9ee391118aafe6f3cf7df4fa5de3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gab7ca9ee391118aafe6f3cf7df4fa5de3">isHex</a> (char c)</td></tr>
<tr class="memdesc:gab7ca9ee391118aafe6f3cf7df4fa5de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this character is a valid hex character or if this is whitespace (The character can be included in a valid hexstring).  <a href="#gab7ca9ee391118aafe6f3cf7df4fa5de3">More...</a><br /></td></tr>
<tr class="separator:gab7ca9ee391118aafe6f3cf7df4fa5de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39003da4dc8a0b8999f1325c2f96f641"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga39003da4dc8a0b8999f1325c2f96f641">isHexDigit</a> (char c)</td></tr>
<tr class="memdesc:ga39003da4dc8a0b8999f1325c2f96f641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this character is a valid hex character.  <a href="#ga39003da4dc8a0b8999f1325c2f96f641">More...</a><br /></td></tr>
<tr class="separator:ga39003da4dc8a0b8999f1325c2f96f641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac873a37c53fdd922d5b36efd737e3ec3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gac873a37c53fdd922d5b36efd737e3ec3">isBase64</a> (char c, const uint8_t *rules)</td></tr>
<tr class="memdesc:gac873a37c53fdd922d5b36efd737e3ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this character is a valid base 64 character or if this is whitespace (A character can be included in a valid base 64 string).  <a href="#gac873a37c53fdd922d5b36efd737e3ec3">More...</a><br /></td></tr>
<tr class="separator:gac873a37c53fdd922d5b36efd737e3ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad10d15454308230fbef54bdd43001ed2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gad10d15454308230fbef54bdd43001ed2">isBase64Digit</a> (char c, const uint8_t *rules)</td></tr>
<tr class="memdesc:gad10d15454308230fbef54bdd43001ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this character is a valid base 64 character.  <a href="#gad10d15454308230fbef54bdd43001ed2">More...</a><br /></td></tr>
<tr class="separator:gad10d15454308230fbef54bdd43001ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga175f401662f82c1e2ef822a9e1fd0b57"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga175f401662f82c1e2ef822a9e1fd0b57">base64Index</a> (char c, const uint8_t *rules)</td></tr>
<tr class="memdesc:ga175f401662f82c1e2ef822a9e1fd0b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the base 64 index of the given character.  <a href="#ga175f401662f82c1e2ef822a9e1fd0b57">More...</a><br /></td></tr>
<tr class="separator:ga175f401662f82c1e2ef822a9e1fd0b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cf48d232ffbc9000c4d8547120f8b2d"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga3cf48d232ffbc9000c4d8547120f8b2d">base64Char</a> (uint8_t id, const uint8_t *rules)</td></tr>
<tr class="memdesc:ga3cf48d232ffbc9000c4d8547120f8b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the base 64 character of the given index.  <a href="#ga3cf48d232ffbc9000c4d8547120f8b2d">More...</a><br /></td></tr>
<tr class="separator:ga3cf48d232ffbc9000c4d8547120f8b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ba8a1787f69d44d6e40db041fbd786"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga55ba8a1787f69d44d6e40db041fbd786">atcab_base64decode_</a> (const char *encoded, size_t encoded_size, uint8_t *data, size_t *data_size, const uint8_t *rules)</td></tr>
<tr class="memdesc:ga55ba8a1787f69d44d6e40db041fbd786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode base64 string to data with ruleset option.  <a href="#ga55ba8a1787f69d44d6e40db041fbd786">More...</a><br /></td></tr>
<tr class="separator:ga55ba8a1787f69d44d6e40db041fbd786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1593f87c555ab964d3ebd5edd49aeb0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga1593f87c555ab964d3ebd5edd49aeb0b">atcab_base64decode</a> (const char *encoded, size_t encoded_size, uint8_t *data, size_t *data_size)</td></tr>
<tr class="memdesc:ga1593f87c555ab964d3ebd5edd49aeb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode base64 string to data.  <a href="#ga1593f87c555ab964d3ebd5edd49aeb0b">More...</a><br /></td></tr>
<tr class="separator:ga1593f87c555ab964d3ebd5edd49aeb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeff0177acf29e6e7b134a14d7119d69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#gaeeff0177acf29e6e7b134a14d7119d69">atcab_base64encode_</a> (const uint8_t *data, size_t data_size, char *encoded, size_t *encoded_size, const uint8_t *rules)</td></tr>
<tr class="memdesc:gaeeff0177acf29e6e7b134a14d7119d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode data as base64 string with ruleset option.  <a href="#gaeeff0177acf29e6e7b134a14d7119d69">More...</a><br /></td></tr>
<tr class="separator:gaeeff0177acf29e6e7b134a14d7119d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b7e341b530fcac3f4eaae874bb36422"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga4b7e341b530fcac3f4eaae874bb36422">atcab_base64encode</a> (const uint8_t *data, size_t data_size, char *encoded, size_t *encoded_size)</td></tr>
<tr class="memdesc:ga4b7e341b530fcac3f4eaae874bb36422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode data as base64 string.  <a href="#ga4b7e341b530fcac3f4eaae874bb36422">More...</a><br /></td></tr>
<tr class="separator:ga4b7e341b530fcac3f4eaae874bb36422"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga692423e9c45adde594c36360756b8882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00913.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga692423e9c45adde594c36360756b8882">_gDevice</a></td></tr>
<tr class="separator:ga692423e9c45adde594c36360756b8882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50731dca3906502d901f5762aa4d9e71"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga50731dca3906502d901f5762aa4d9e71">atcab_b64rules_default</a> [4]</td></tr>
<tr class="separator:ga50731dca3906502d901f5762aa4d9e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87ae4178e0a5543d5b2192f26e049bd2"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga87ae4178e0a5543d5b2192f26e049bd2">atcab_b64rules_mime</a> [4]</td></tr>
<tr class="separator:ga87ae4178e0a5543d5b2192f26e049bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cccbbcdbcb7230cc0f8ea8a596feebe"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00916.html#ga1cccbbcdbcb7230cc0f8ea8a596feebe">atcab_b64rules_urlsafe</a> [4]</td></tr>
<tr class="separator:ga1cccbbcdbcb7230cc0f8ea8a596feebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>These methods provide the most convenient, simple API to CryptoAuth chips. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gad4d0b05dd9b5d0987e24eef9674922ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4d0b05dd9b5d0987e24eef9674922ce">&#9670;&nbsp;</a></span>ATCA_AES_GCM_IV_STD_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ATCA_AES_GCM_IV_STD_LENGTH&#160;&#160;&#160;12</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga66d0b18bba952f5acdee8cf68b889b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66d0b18bba952f5acdee8cf68b889b75">&#9670;&nbsp;</a></span>BLOCK_NUMBER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLOCK_NUMBER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a</td><td>)</td>
          <td>&#160;&#160;&#160;(a / 32)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9e5ab0fea07bd91159ab96f18105d1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e5ab0fea07bd91159ab96f18105d1b1">&#9670;&nbsp;</a></span>WORD_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORD_OFFSET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a</td><td>)</td>
          <td>&#160;&#160;&#160;((a % 32) / 4)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaa702726fe160635225abc3c1ed421f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa702726fe160635225abc3c1ed421f7e">&#9670;&nbsp;</a></span>atca_aes_cbc_ctx_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="a00992.html">atca_aes_cbc_ctx</a>  <a class="el" href="a00916.html#gaa702726fe160635225abc3c1ed421f7e">atca_aes_cbc_ctx_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga05fa8c58bf4408381db8871b0dca64b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05fa8c58bf4408381db8871b0dca64b6">&#9670;&nbsp;</a></span>atca_aes_cmac_ctx_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="a00996.html">atca_aes_cmac_ctx</a>  <a class="el" href="a00916.html#ga05fa8c58bf4408381db8871b0dca64b6">atca_aes_cmac_ctx_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga52b18f051752d214a2d5b485270f5b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52b18f051752d214a2d5b485270f5b15">&#9670;&nbsp;</a></span>atca_aes_ctr_ctx_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="a01000.html">atca_aes_ctr_ctx</a> <a class="el" href="a00916.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4c1f62e502c168be9261d2af921e78ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c1f62e502c168be9261d2af921e78ba">&#9670;&nbsp;</a></span>atca_hmac_sha256_ctx_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00916.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> <a class="el" href="a00916.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga530ccce9f617be7dbf3661e19a4c0546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga530ccce9f617be7dbf3661e19a4c0546">&#9670;&nbsp;</a></span>atca_sha256_ctx_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="a01004.html">atca_sha256_ctx</a>  <a class="el" href="a00916.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5802cd6847a837458604db5dbec4a6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5802cd6847a837458604db5dbec4a6f0">&#9670;&nbsp;</a></span>_atcab_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> _atcab_exit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>common cleanup code which idles the device after any operation </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gad115ce255664a48b80e90ea19c156b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad115ce255664a48b80e90ea19c156b79">&#9670;&nbsp;</a></span>atcab_aes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_aes </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>aes_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aes_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the AES-128 encrypt, decrypt, or GFM calculation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The mode for the AES command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aes_in</td><td>Input data to the AES command (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aes_out</td><td>Output data from the AES command is returned here (16 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga7c66e1b8b31bb87be3de6c9a9084c21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c66e1b8b31bb87be3de6c9a9084c21e">&#9670;&nbsp;</a></span>atcab_aes_cbc_decrypt_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_aes_cbc_decrypt_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#gaa702726fe160635225abc3c1ed421f7e">atca_aes_cbc_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypt a block of data using CBC mode and a key within the ATECC608A. <a class="el" href="a00916.html#gabc41b824cdc9b10efa46bcbf74850184" title="Initialize context for AES CBC operation. ">atcab_aes_cbc_init()</a> should be called before the first use of this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES CBC context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ciphertext</td><td>Ciphertext to be decrypted (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plaintext</td><td>Decrypted data is returned here (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga7414e3dc8215cedc1bffc6cf576d7d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7414e3dc8215cedc1bffc6cf576d7d1e">&#9670;&nbsp;</a></span>atcab_aes_cbc_encrypt_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_aes_cbc_encrypt_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#gaa702726fe160635225abc3c1ed421f7e">atca_aes_cbc_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encrypt a block of data using CBC mode and a key within the ATECC608A. <a class="el" href="a00916.html#gabc41b824cdc9b10efa46bcbf74850184" title="Initialize context for AES CBC operation. ">atcab_aes_cbc_init()</a> should be called before the first use of this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES CBC context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plaintext</td><td>Plaintext to be encrypted (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ciphertext</td><td>Encrypted data is returned here (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gabc41b824cdc9b10efa46bcbf74850184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc41b824cdc9b10efa46bcbf74850184">&#9670;&nbsp;</a></span>atcab_aes_cbc_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_aes_cbc_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#gaa702726fe160635225abc3c1ed421f7e">atca_aes_cbc_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>key_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>iv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize context for AES CBC operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES CBC context to be initialized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_block</td><td>Index of the 16-byte block to use within the key location for the actual key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iv</td><td>Initialization vector (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gac0be51b283b107465dcf42758ca31687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0be51b283b107465dcf42758ca31687">&#9670;&nbsp;</a></span>atcab_aes_cmac_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_aes_cmac_finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#ga05fa8c58bf4408381db8871b0dca64b6">atca_aes_cmac_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>cmac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmac_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish a CMAC operation returning the CMAC value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES-128 CMAC context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cmac</td><td>CMAC is returned here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmac_size</td><td>Size of CMAC requested in bytes (max 16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga84506ff4105e63823c99527788d36d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84506ff4105e63823c99527788d36d52">&#9670;&nbsp;</a></span>atcab_aes_cmac_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_aes_cmac_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#ga05fa8c58bf4408381db8871b0dca64b6">atca_aes_cmac_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>key_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a CMAC calculation using an AES-128 key in the ATECC608A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES-128 CMAC context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_block</td><td>Index of the 16-byte block to use within the key location for the actual key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga0cf22e893c713890faeb9fa8784760b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cf22e893c713890faeb9fa8784760b1">&#9670;&nbsp;</a></span>atcab_aes_cmac_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_aes_cmac_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#ga05fa8c58bf4408381db8871b0dca64b6">atca_aes_cmac_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add data to an initialized CMAC calculation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES-128 CMAC context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of the data to be added in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga76937b340e59be4dc1a30d8c7b76ebe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76937b340e59be4dc1a30d8c7b76ebe0">&#9670;&nbsp;</a></span>atcab_aes_ctr_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_aes_ctr_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process a block of data using CTR mode and a key within the ATECC608A device. <a class="el" href="a00916.html#ga0db7d24f31dc2dd4805e3c433ae604ad" title="Initialize context for AES CTR operation with an existing IV, which is common when start a decrypt op...">atcab_aes_ctr_init()</a> or <a class="el" href="a00916.html#gae7558905ea6a82c4bd50d4b99e954d91" title="Initialize context for AES CTR operation with a random nonce and counter set to 0 as the IV...">atcab_aes_ctr_init_rand()</a> should be called before the first use of this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES CTR context structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Input data to be processed (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Output data is returned here (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, ATCA_INVALID_SIZE on counter overflow, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gada9491be0c81fb18b021f71b9a6eda3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada9491be0c81fb18b021f71b9a6eda3e">&#9670;&nbsp;</a></span>atcab_aes_ctr_decrypt_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_aes_ctr_decrypt_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypt a block of data using CTR mode and a key within the ATECC608A device. <a class="el" href="a00916.html#ga0db7d24f31dc2dd4805e3c433ae604ad" title="Initialize context for AES CTR operation with an existing IV, which is common when start a decrypt op...">atcab_aes_ctr_init()</a> or <a class="el" href="a00916.html#gae7558905ea6a82c4bd50d4b99e954d91" title="Initialize context for AES CTR operation with a random nonce and counter set to 0 as the IV...">atcab_aes_ctr_init_rand()</a> should be called before the first use of this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES CTR context structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ciphertext</td><td>Ciphertext to be decrypted (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plaintext</td><td>Decrypted data is returned here (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, ATCA_INVALID_SIZE on counter overflow, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga7182e48a847f9c1b31f19c60f373e2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7182e48a847f9c1b31f19c60f373e2da">&#9670;&nbsp;</a></span>atcab_aes_ctr_encrypt_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_aes_ctr_encrypt_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encrypt a block of data using CTR mode and a key within the ATECC608A device. <a class="el" href="a00916.html#ga0db7d24f31dc2dd4805e3c433ae604ad" title="Initialize context for AES CTR operation with an existing IV, which is common when start a decrypt op...">atcab_aes_ctr_init()</a> or <a class="el" href="a00916.html#gae7558905ea6a82c4bd50d4b99e954d91" title="Initialize context for AES CTR operation with a random nonce and counter set to 0 as the IV...">atcab_aes_ctr_init_rand()</a> should be called before the first use of this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES CTR context structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plaintext</td><td>Plaintext to be encrypted (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ciphertext</td><td>Encrypted data is returned here (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, ATCA_INVALID_SIZE on counter overflow, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga475b72450dcd21c822de5cb366197927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga475b72450dcd21c822de5cb366197927">&#9670;&nbsp;</a></span>atcab_aes_ctr_increment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_aes_ctr_increment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments AES CTR counter value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>AES CTR context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga0db7d24f31dc2dd4805e3c433ae604ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0db7d24f31dc2dd4805e3c433ae604ad">&#9670;&nbsp;</a></span>atcab_aes_ctr_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_aes_ctr_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>key_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>counter_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>iv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize context for AES CTR operation with an existing IV, which is common when start a decrypt operation. </p>
<p>The IV is a combination of nonce (left-field) and big-endian counter (right-field). The counter_size field sets the size of the counter and the remaining bytes are assumed to be the nonce.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES CTR context to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_block</td><td>Index of the 16-byte block to use within the key location for the actual key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_size</td><td>Size of counter in IV in bytes. 4 bytes is a common size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iv</td><td>Initialization vector (concatenation of nonce and counter) 16 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gae7558905ea6a82c4bd50d4b99e954d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7558905ea6a82c4bd50d4b99e954d91">&#9670;&nbsp;</a></span>atcab_aes_ctr_init_rand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_aes_ctr_init_rand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>key_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>counter_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>iv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize context for AES CTR operation with a random nonce and counter set to 0 as the IV, which is common when starting an encrypt operation. </p>
<p>The IV is a combination of nonce (left-field) and big-endian counter (right-field). The counter_size field sets the size of the counter and the remaining bytes are assumed to be the nonce.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES CTR context to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_block</td><td>Index of the 16-byte block to use within the key location for the actual key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_size</td><td>Size of counter in IV in bytes. 4 bytes is a common size. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iv</td><td>Initialization vector (concatenation of nonce and counter) is returned here (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga9658e84055727e6357cf7ef636b4e398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9658e84055727e6357cf7ef636b4e398">&#9670;&nbsp;</a></span>atcab_aes_decrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_aes_decrypt </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>key_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an AES-128 decrypt operation with a key in the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_block</td><td>Index of the 16-byte block to use within the key location for the actual key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ciphertext</td><td>Input ciphertext to be decrypted (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plaintext</td><td>Output plaintext is returned here (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gacc9a58dc49f91674213f34fa7bbd05e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc9a58dc49f91674213f34fa7bbd05e1">&#9670;&nbsp;</a></span>atcab_aes_encrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_aes_encrypt </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>key_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an AES-128 encrypt operation with a key in the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_block</td><td>Index of the 16-byte block to use within the key location for the actual key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plaintext</td><td>Input plaintext to be encrypted (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ciphertext</td><td>Output ciphertext is returned here (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga5554940ed4c7c7e28652ce6923cf9314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5554940ed4c7c7e28652ce6923cf9314">&#9670;&nbsp;</a></span>atcab_aes_gfm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_aes_gfm </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a Galois Field Multiply (GFM) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>First input value (16 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Second input value (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>GFM result is returned here (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga1593f87c555ab964d3ebd5edd49aeb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1593f87c555ab964d3ebd5edd49aeb0b">&#9670;&nbsp;</a></span>atcab_base64decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_base64decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>encoded_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>byte_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>array_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode base64 string to data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encoded</td><td>Base64 string to be decoded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encoded_len</td><td>Size of the base64 string in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">byte_array</td><td>Decoded data will be returned here. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array_len</td><td>As input, the size of the byte_array buffer. As output, the length of the decoded data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga55ba8a1787f69d44d6e40db041fbd786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55ba8a1787f69d44d6e40db041fbd786">&#9670;&nbsp;</a></span>atcab_base64decode_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_base64decode_ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>encoded_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>rules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode base64 string to data with ruleset option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encoded</td><td>Base64 string to be decoded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encoded_size</td><td>Size of the base64 string in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Decoded data will be returned here. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data_size</td><td>As input, the size of the byte_array buffer. As output, the length of the decoded data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rules</td><td>base64 ruleset to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4b7e341b530fcac3f4eaae874bb36422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b7e341b530fcac3f4eaae874bb36422">&#9670;&nbsp;</a></span>atcab_base64encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_base64encode </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>byte_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>array_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>encoded_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode data as base64 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">byte_array</td><td>Data to be encode in base64. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array_len</td><td>Size of byte_array in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encoded</td><td>Base64 output is returned here. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">encoded_len</td><td>As input, the size of the encoded buffer. As output, the length of the encoded base64 character string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaeeff0177acf29e6e7b134a14d7119d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeff0177acf29e6e7b134a14d7119d69">&#9670;&nbsp;</a></span>atcab_base64encode_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_base64encode_ </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>encoded_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>rules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode data as base64 string with ruleset option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The input byte array that will be converted to base 64 encoded characters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>The length of the byte array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encoded</td><td>The output converted to base 64 encoded characters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">encoded_size</td><td>Input: The size of the encoded buffer, Output: The length of the encoded base 64 character string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rules</td><td>ruleset to use during encoding </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae31a9fd8e9deca79aa5fef0292fe5272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae31a9fd8e9deca79aa5fef0292fe5272">&#9670;&nbsp;</a></span>atcab_bin2hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_bin2hex </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bin_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>hex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hex_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a binary buffer to a hex string for easy reading. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bin</td><td>Input data to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bin_size</td><td>Size of data to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hex</td><td>Buffer that receives hex string. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hex_size</td><td>As input, the size of the hex buffer. As output, the size of the output hex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga121d8391484d9e0c8c0e3f6dbac8285c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga121d8391484d9e0c8c0e3f6dbac8285c">&#9670;&nbsp;</a></span>atcab_bin2hex_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_bin2hex_ </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bin_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>hex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hex_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_pretty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that converts a binary buffer to a hex string suitable for easy reading. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bin</td><td>Input data to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bin_size</td><td>Size of data to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hex</td><td>Buffer that receives hex string. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hex_size</td><td>As input, the size of the hex buffer. As output, the size of the output hex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_pretty</td><td>Indicates whether spaces and new lines should be added for pretty printing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga1518196e269b549eec78087abd130de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1518196e269b549eec78087abd130de7">&#9670;&nbsp;</a></span>atcab_cfg_discover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_cfg_discover </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00936.html">ATCAIfaceCfg</a>&#160;</td>
          <td class="paramname"><em>cfg_array</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_ifaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>auto discovery of crypto auth devices </p>
<p>Calls interface discovery functions and fills in cfg_array up to the maximum number of configurations either found or the size of the array. The cfg_array can have a mixture of interface types (ie: some I2C, some SWI or UART) depending upon which interfaces you've enabled</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">cfg_array</td><td>ptr to an array of interface configs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_ifaces</td><td>maximum size of cfg_array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga114a721517c95d5ba5fcac5b226669d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga114a721517c95d5ba5fcac5b226669d6">&#9670;&nbsp;</a></span>atcab_challenge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_challenge </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a Nonce command in pass-through mode to initialize TempKey to a specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Data to be loaded into TempKey (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaadde4309089c569fd87c24a1a2326cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadde4309089c569fd87c24a1a2326cd4">&#9670;&nbsp;</a></span>atcab_challenge_seed_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_challenge_seed_update </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a Nonce command to generate a random challenge combining a host nonce (num_in) and a device random number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Host nonce to be combined with the device random number (20 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>Internally generated 32-byte random number that was used in the nonce/challenge calculation is returned here. Can be NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga5ba49c05f7b3fb5acaf55df993ccd3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ba49c05f7b3fb5acaf55df993ccd3ee">&#9670;&nbsp;</a></span>atcab_checkmac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_checkmac </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>challenge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares a MAC response with input values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Controls which fields within the device are used in the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location in the CryptoAuth device to use for the MAC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">challenge</td><td>Challenge data (32 bytes) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">response</td><td>MAC response data (32 bytes) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>OtherData parameter (13 bytes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gadb91d2c3601b95f0ad413cf84a4dfd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb91d2c3601b95f0ad413cf84a4dfd87">&#9670;&nbsp;</a></span>atcab_cmp_config_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_cmp_config_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>config_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>same_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares a specified configuration zone with the configuration zone currently on the device. </p>
<p>This only compares the static portions of the configuration zone and skips those that are unique per device (first 16 bytes) and areas that can change after the configuration zone has been locked (e.g. LastKeyUse).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config_data</td><td>Full configuration data to compare the device against. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">same_config</td><td>Result is returned here. True if the static portions on the configuration zones are the same.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>
<p>Max for all configs </p>

</div>
</div>
<a id="gabaaaef242649206029e1c10ac6d1fb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaaaef242649206029e1c10ac6d1fb7d">&#9670;&nbsp;</a></span>atcab_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_counter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>counter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>counter_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Counter functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>the mode used for the counter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>The counter to be used </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_value</td><td>pointer to the counter value returned from device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga6e510e056ea16a0a34b405b7ca378f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e510e056ea16a0a34b405b7ca378f16">&#9670;&nbsp;</a></span>atcab_counter_increment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_counter_increment </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>counter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>counter_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments one of the device's monotonic counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>Counter to be incremented </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_value</td><td>New value of the counter is returned here. Can be NULL if not needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaeee666028a097659af69cc828a6bd68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeee666028a097659af69cc828a6bd68b">&#9670;&nbsp;</a></span>atcab_counter_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_counter_read </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>counter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>counter_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one of the device's monotonic counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>Counter to be read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_value</td><td>Counter value is returned here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga34b7b6d46868f0d63d195216ef9939b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34b7b6d46868f0d63d195216ef9939b1">&#9670;&nbsp;</a></span>atcab_derivekey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_derivekey </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>target_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the DeviveKey command for deriving a new key from a nonce (TempKey) and an existing key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Bit 2 must match the value in TempKey.SourceFlag </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_key</td><td>Key slot to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac</td><td>Optional 32 byte MAC used to validate operation. NULL if not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga6fc480ad2824df6309f4f370ffad15f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fc480ad2824df6309f4f370ffad15f9">&#9670;&nbsp;</a></span>atcab_ecdh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_ecdh </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDH command with a private key in a slot and the premaster secret is returned in the clear. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of key for ECDH computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH premaster secret is returned here. 32 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a id="ga211c9405bb5049dd4a5da92d25c83f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga211c9405bb5049dd4a5da92d25c83f3c">&#9670;&nbsp;</a></span>atcab_ecdh_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_ecdh_base </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out_nonce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base function for generating premaster secret key using ECDH. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode to be used for ECDH computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of key for ECDH computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH pre-master secret is returned here (32 bytes) if returned directly. Otherwise NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_nonce</td><td>Nonce used to encrypt pre-master secret. NULL if output encryption not used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gab6e0c175cbcb5f794b12a8ec22485176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6e0c175cbcb5f794b12a8ec22485176">&#9670;&nbsp;</a></span>atcab_ecdh_enc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_ecdh_enc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>read_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>read_key_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDH command with a private key in a slot and the premaster secret is read from the next slot. </p>
<p>This function only works for even numbered slots with the proper configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of key for ECDH computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH premaster secret is returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">read_key</td><td>Read key for the premaster secret slot (key_id|1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">read_key_id</td><td>Read key slot for read_key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga975f7303086190d3b6f76c367583d622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga975f7303086190d3b6f76c367583d622">&#9670;&nbsp;</a></span>atcab_ecdh_ioenc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_ecdh_ioenc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>io_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDH command with a private key in a slot and the premaster secret is returned encrypted using the IO protection key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of key for ECDH computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH premaster secret is returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_key</td><td>IO protection key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gac244b83b061ffd8ae3d59b5f973baa53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac244b83b061ffd8ae3d59b5f973baa53">&#9670;&nbsp;</a></span>atcab_ecdh_tempkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_ecdh_tempkey </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDH command with a private key in TempKey and the premaster secret is returned in the clear. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH premaster secret is returned here (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gafaccb0c9d12154b0c5b917f89f233721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaccb0c9d12154b0c5b917f89f233721">&#9670;&nbsp;</a></span>atcab_ecdh_tempkey_ioenc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_ecdh_tempkey_ioenc </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>io_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDH command with a private key in TempKey and the premaster secret is returned encrypted using the IO protection key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH premaster secret is returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_key</td><td>IO protection key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga70751ea87f2cf913986bc7bca2cc661f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70751ea87f2cf913986bc7bca2cc661f">&#9670;&nbsp;</a></span>atcab_gendig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_gendig </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>other_data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues a GenDig command, which performs a SHA256 hash on the source data indicated by zone with the contents of TempKey. See the CryptoAuth datasheet for your chip to see what the values of zone correspond to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Designates the source of the data to hash with TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Indicates the key, OTP block, or message order for shared nonce mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>Four bytes of data for SHA calculation when using a NoMac key, 32 bytes for "Shared Nonce" mode, otherwise ignored (can be NULL). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data_size</td><td>Size of other_data in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga617bdbdce7b5736351d93214d44c5b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga617bdbdce7b5736351d93214d44c5b8f">&#9670;&nbsp;</a></span>atcab_genkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_genkey </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues GenKey command, which generates a new random private key in slot and returns the public key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot number where an ECC private key is configured. Can also be ATCA_TEMPKEY_KEYID to generate a private key in TempKey. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>Public key will be returned here. Format will be the X and Y integers in big-endian format. 64 bytes for P256 curve. Set to NULL if public key isn't required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaa8b6953ad2c7f749e61566fd38fe6903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8b6953ad2c7f749e61566fd38fe6903">&#9670;&nbsp;</a></span>atcab_genkey_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_genkey_base </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues GenKey command, which can generate a private key, compute a public key, nd/or compute a digest of a public key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines what operations the GenKey command performs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot to perform the GenKey command on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>OtherData for PubKey digest calculation. Can be set to NULL otherwise. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>If the mode indicates a public key will be calculated, it will be returned here. Format will be the X and Y integers in big-endian format. 64 bytes for P256 curve. Set to NULL if public key isn't required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gabdfeb1f8d28039e9b30d4e39b8caa33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdfeb1f8d28039e9b30d4e39b8caa33a">&#9670;&nbsp;</a></span>atcab_get_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_get_addr </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the address given the zone, slot, block, and offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to get address from. Config(0), OTP(1), or Data(2) which requires a slot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot Id number for data zone and zero for other zones. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Block number within the data or configuration or OTP zone . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset Number within the block of data or configuration or OTP zone. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addr</td><td>Pointer to the address of data or configuration or OTP zone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga4af82005556c549c30e1c4bd35d4f4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4af82005556c549c30e1c4bd35d4f4e4">&#9670;&nbsp;</a></span>atcab_get_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00913.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> atcab_get_device </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the global device object. </p>
<dl class="section return"><dt>Returns</dt><dd>instance of global ATCADevice </dd></dl>

</div>
</div>
<a id="gad2096a4618dd37c48ed48847fe63d844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2096a4618dd37c48ed48847fe63d844">&#9670;&nbsp;</a></span>atcab_get_pubkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_get_pubkey </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses GenKey command to calculate the public key from an existing private key in a slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot number of the private key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>Public key will be returned here. Format will be the X and Y integers in big-endian format. 64 bytes for P256 curve. Set to NULL if public key isn't required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga7a823d2a391bf80ff336eb2ccbd37412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a823d2a391bf80ff336eb2ccbd37412">&#9670;&nbsp;</a></span>atcab_get_zone_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_get_zone_size </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the specified zone in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to get size information from. Config(0), OTP(1), or Data(2) which requires a slot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>If zone is Data(2), the slot to query for size. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Zone size is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga481179181349c801c16fc1ab698f2f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga481179181349c801c16fc1ab698f2f24">&#9670;&nbsp;</a></span>atcab_hex2bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_hex2bin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hex_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bin_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that converts a hex string to binary buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hex</td><td>Input buffer to convert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hex_size</td><td>Length of buffer to convert </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bin</td><td>Buffer that receives binary </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bin_size</td><td>As input, the size of the bin buffer. As output, the size of the bin data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga45f1d09a51f7a1f68916536ab5125b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45f1d09a51f7a1f68916536ab5125b9d">&#9670;&nbsp;</a></span>atcab_hmac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_hmac </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues a HMAC command, which computes an HMAC/SHA-256 digest of a key stored in the device, a challenge, and other information on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Controls which fields within the device are used in the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Which key is to be used to generate the response. Bits 0:3 only are used to select a slot but all 16 bits are used in the HMAC message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>HMAC digest is returned in this buffer (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga4bf8b665fe1712626a480742c2daa16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bf8b665fe1712626a480742c2daa16b">&#9670;&nbsp;</a></span>atcab_hw_sha2_256()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_hw_sha2_256 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the SHA command to compute a SHA-256 digest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Message data to be hashed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of data in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>Digest is returned here (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga6ed7e645262fcc32b00d8a9facf09e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ed7e645262fcc32b00d8a9facf09e91">&#9670;&nbsp;</a></span>atcab_hw_sha2_256_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_hw_sha2_256_finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish SHA-256 digest for a SHA context for performing a hardware SHA-256 operation on a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>SHA256 context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>SHA256 digest is returned here (32 bytes)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gade49e7746864105730fa7d531645ff62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade49e7746864105730fa7d531645ff62">&#9670;&nbsp;</a></span>atcab_hw_sha2_256_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_hw_sha2_256_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a SHA context for performing a hardware SHA-256 operation on a device. Note that only one SHA operation can be run at a time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>SHA256 context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga67f2ce6224651d9cc65e9915e35558bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67f2ce6224651d9cc65e9915e35558bd">&#9670;&nbsp;</a></span>atcab_hw_sha2_256_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_hw_sha2_256_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add message data to a SHA context for performing a hardware SHA-256 operation on a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>SHA256 context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Message data to be added to hash. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of data in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaf47433a371b9fcb8d65a4214cd9e4fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf47433a371b9fcb8d65a4214cd9e4fa0">&#9670;&nbsp;</a></span>atcab_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_idle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>idle the CryptoAuth device </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga6e19ecd60be4c74665d9ec142e460771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e19ecd60be4c74665d9ec142e460771">&#9670;&nbsp;</a></span>atcab_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_info </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>revision</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the Info command to get the device revision (DevRev). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">revision</td><td>Device revision is returned here (4 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga806d07982fda5c30755af6b5b4ef9314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga806d07982fda5c30755af6b5b4ef9314">&#9670;&nbsp;</a></span>atcab_info_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_info_base </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>param2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues an Info command, which return internal device information and can control GPIO and the persistent latch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Selects which mode to be used for info command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param2</td><td>Selects the particular fields for the mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_data</td><td>Response from info command (4 bytes). Can be set to NULL if not required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga376b6ae92f14c60fba4ca5c6461e0b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga376b6ae92f14c60fba4ca5c6461e0b48">&#9670;&nbsp;</a></span>atcab_info_get_latch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_info_get_latch </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the Info command to get the persistent latch current state for an ATECC608A device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">state</td><td>The state is returned here. Set (true) or Cler (false).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga2649126606db8a0b64ae8e19d09f6600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2649126606db8a0b64ae8e19d09f6600">&#9670;&nbsp;</a></span>atcab_info_set_latch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_info_set_latch </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the Info command to set the persistent latch state for an ATECC608A device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">state</td><td>Persistent latch state. Set (true) or clear (false).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gacdc4fa3d2f2f6d197af8c10ab1f288b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdc4fa3d2f2f6d197af8c10ab1f288b8">&#9670;&nbsp;</a></span>atcab_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00936.html">ATCAIfaceCfg</a> *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a global ATCADevice object used by Basic API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>Logical interface configuration. Some predefined configurations can be found in <a class="el" href="a00095.html" title="a set of default configurations for various ATCA devices and interfaces ">atca_cfgs.h</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gab22d2a32e6c32c14c4e58ce794ff3ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab22d2a32e6c32c14c4e58ce794ff3ec4">&#9670;&nbsp;</a></span>atcab_init_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_init_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00913.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>ca_device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the global ATCADevice object to point to one of your choosing for use with all the atcab_ basic API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ca_device</td><td>ATCADevice instance to use as the global Basic API crypto device instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaefce484222bdbedef37787a9b10d4426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefce484222bdbedef37787a9b10d4426">&#9670;&nbsp;</a></span>atcab_is_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_is_locked </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command, which reads the configuration zone to see if the specified zone is locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>The zone to query for locked (use LOCK_ZONE_CONFIG or LOCK_ZONE_DATA). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_locked</td><td>Lock state returned here. True if locked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga802de50265ff91dc30dd7c93d9e026e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga802de50265ff91dc30dd7c93d9e026e1">&#9670;&nbsp;</a></span>atcab_is_slot_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_is_slot_locked </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command, which reads the configuration zone to see if the specified slot is locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot to query for locked (slot 0-15) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_locked</td><td>Lock state returned here. True if locked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga40a6c01492a76366f9402302b527c4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40a6c01492a76366f9402302b527c4e1">&#9670;&nbsp;</a></span>atcab_kdf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_kdf </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>details</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out_nonce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the KDF command, which derives a new key in PRF, AES, or HKDF modes. </p>
<p>Generally this function combines a source key with an input string and creates a result key/digest/array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines KDF algorithm (PRF,AES,HKDF), source key location, and target key locations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Source and target key slots if locations are in the EEPROM. Source key slot is the LSB and target key slot is the MSB. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">details</td><td>Further information about the computation, depending on the algorithm (4 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Input value from system (up to 128 bytes). Actual size of message is 16 bytes for AES algorithm or is encoded in the MSB of the details parameter for other algorithms. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_data</td><td>Output of the KDF function is returned here. If the result remains in the device, this can be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_nonce</td><td>If the output is encrypted, a 32 byte random nonce generated by the device is returned here. If output encryption is not used, this can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga25d2895192d93c524f5dba92a492cdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25d2895192d93c524f5dba92a492cdfb">&#9670;&nbsp;</a></span>atcab_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_lock </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>summary_crc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Lock command prevents future modifications of the Configuration and/or Data and OTP zones. If the device is so configured, then this command can be used to lock individual data slots. This command fails if the designated area is already locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Zone, and/or slot, and summary check (bit 7). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">summary_crc</td><td>CRC of the config or data zones. Ignored for slot locks or when mode bit 7 is set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga7cd67c03c7184ad041e2c0ad4f27db23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cd67c03c7184ad041e2c0ad4f27db23">&#9670;&nbsp;</a></span>atcab_lock_config_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_lock_config_zone </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unconditionally (no CRC required) lock the config zone. </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga0698e0c55ad700fe57498321e842cb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0698e0c55ad700fe57498321e842cb38">&#9670;&nbsp;</a></span>atcab_lock_config_zone_crc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_lock_config_zone_crc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>summary_crc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the config zone with summary CRC. </p>
<p>The CRC is calculated over the entire config zone contents. 88 bytes for ATSHA devices, 128 bytes for ATECC devices. Lock will fail if the provided CRC doesn't match the internally calculated one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">summary_crc</td><td>Expected CRC over the config zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga958190a9182d1b54f82fbca8216406ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga958190a9182d1b54f82fbca8216406ea">&#9670;&nbsp;</a></span>atcab_lock_data_slot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_lock_data_slot </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock an individual slot in the data zone on an ATECC device. Not available for ATSHA devices. Slot must be configured to be slot lockable (KeyConfig.Lockable=1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot to be locked in data zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga8020aa89a5bed09ad35320b78e0fb890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8020aa89a5bed09ad35320b78e0fb890">&#9670;&nbsp;</a></span>atcab_lock_data_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_lock_data_zone </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unconditionally (no CRC required) lock the data zone (slots and OTP). </p>
<p>ConfigZone must be locked and DataZone must be unlocked for the zone to be successfully locked.</p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaf29e398e2aca927ab4606aa1ec0308c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf29e398e2aca927ab4606aa1ec0308c6">&#9670;&nbsp;</a></span>atcab_lock_data_zone_crc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_lock_data_zone_crc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>summary_crc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the data zone (slots and OTP) with summary CRC. </p>
<p>The CRC is calculated over the concatenated contents of all the slots and OTP at the end. Private keys (KeyConfig.Private=1) are skipped. Lock will fail if the provided CRC doesn't match the internally calculated one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">summary_crc</td><td>Expected CRC over the data zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga98cb802fbb5d78cd552bb05c21d6c791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98cb802fbb5d78cd552bb05c21d6c791">&#9670;&nbsp;</a></span>atcab_mac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_mac </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>challenge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes MAC command, which computes a SHA-256 digest of a key stored in the device, a challenge, and other information on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Controls which fields within the device are used in the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key in the CryptoAuth device to use for the MAC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">challenge</td><td>Challenge message (32 bytes). May be NULL if mode indicates a challenge isn't required. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>MAC response is returned here (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga2293df1c1c794496790bae25d3844fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2293df1c1c794496790bae25d3844fa5">&#9670;&nbsp;</a></span>atcab_nonce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_nonce </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a Nonce command in pass-through mode to initialize TempKey to a specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Data to be loaded into TempKey (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaf8e10791759a8a5e5dcd82774f4895d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8e10791759a8a5e5dcd82774f4895d6">&#9670;&nbsp;</a></span>atcab_nonce_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_nonce_base </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Nonce command, which loads a random or fixed nonce/data into the device for use by subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Controls the mechanism of the internal RNG or fixed write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zero</td><td>Param2, normally 0, but can be used to indicate a nonce calculation mode (bit 15). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Input value to either be included in the nonce calculation in random modes (20 bytes) or to be written directly (32 bytes or 64 bytes(ATECC608A)) in pass-through mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>If using a random mode, the internally generated 32-byte random number that was used in the nonce calculation is returned here. Can be NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga2239ae3a87c341a48aa108bd82a58552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2239ae3a87c341a48aa108bd82a58552">&#9670;&nbsp;</a></span>atcab_nonce_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_nonce_load </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_in_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a Nonce command in pass-through mode to load one of the device's internal buffers with a fixed value. </p>
<p>For the ATECC608A, available targets are TempKey (32 or 64 bytes), Message Digest Buffer (32 or 64 bytes), or the Alternate Key Buffer (32 bytes). For all other devices, only TempKey (32 bytes) is available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Target device buffer to load. Can be NONCE_MODE_TARGET_TEMPKEY, NONCE_MODE_TARGET_MSGDIGBUF, or NONCE_MODE_TARGET_ALTKEYBUF. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Data to load into the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in_size</td><td>Size of num_in in bytes. Can be 32 or 64 bytes depending on device and target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaed67d447d547c67b7b8be6b958d1fb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed67d447d547c67b7b8be6b958d1fb5c">&#9670;&nbsp;</a></span>atcab_nonce_rand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_nonce_rand </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a Nonce command to generate a random nonce combining a host nonce (num_in) and a device random number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Host nonce to be combined with the device random number (20 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>Internally generated 32-byte random number that was used in the nonce/challenge calculation is returned here. Can be NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga72601de415fd0bbc73faa1ddbc52e56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72601de415fd0bbc73faa1ddbc52e56e">&#9670;&nbsp;</a></span>atcab_printbin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_printbin </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bin_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga248355e3b4bcdd5d728f214fc2eb79e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga248355e3b4bcdd5d728f214fc2eb79e4">&#9670;&nbsp;</a></span>atcab_printbin_label()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_printbin_label </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bin_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1f88c481b376a7be9112ff081c4ad854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f88c481b376a7be9112ff081c4ad854">&#9670;&nbsp;</a></span>atcab_printbin_sp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_printbin_sp </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bin_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad01e8e785073d8655de9116e7df8e7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad01e8e785073d8655de9116e7df8e7b5">&#9670;&nbsp;</a></span>atcab_priv_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_priv_write </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>priv_key</em>[36], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>write_key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>write_key</em>[32]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes PrivWrite command, to write externally generated ECC private keys into the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot to write the external private key into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priv_key</td><td>External private key (36 bytes) to be written. The first 4 bytes should be zero for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">write_key_id</td><td>Write key slot. Ignored if write_key is NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">write_key</td><td>Write key (32 bytes). If NULL, perform an unencrypted PrivWrite, which is only available when the data zone is unlocked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga4fa442396dfbb89e59dfca837b565cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fa442396dfbb89e59dfca837b565cec">&#9670;&nbsp;</a></span>atcab_random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_random </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Random command, which generates a 32 byte random number from the CryptoAuth device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>32 bytes of random data is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga750704332198726725a327344f4f7dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga750704332198726725a327344f4f7dd5">&#9670;&nbsp;</a></span>atcab_read_bytes_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_read_bytes_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to read an arbitrary number of bytes from any zone configured for clear reads. </p>
<p>This function will issue the Read command as many times as is required to read the requested data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to read data from. Option are <a class="el" href="a00912.html#gadd3796a1d4de55604283aef5a70f7945" title="Configuration zone. ">ATCA_ZONE_CONFIG(0)</a>, <a class="el" href="a00912.html#ga547efc6fa3cb0501b2e53f80023dff7e" title="OTP (One Time Programming) zone. ">ATCA_ZONE_OTP(1)</a>, or <a class="el" href="a00912.html#ga4c65b241280290fae9fd4faa9d7a292b" title="Data zone. ">ATCA_ZONE_DATA(2)</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number to read from if zone is <a class="el" href="a00912.html#ga4c65b241280290fae9fd4faa9d7a292b" title="Data zone. ">ATCA_ZONE_DATA(2)</a>. Ignored for all other zones. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Byte offset within the zone to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Read data is returned here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes to read starting from the offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga8ef47330eef6bc72ae8f7a8ef026dae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ef47330eef6bc72ae8f7a8ef026dae3">&#9670;&nbsp;</a></span>atcab_read_config_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_read_config_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>config_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command to read the complete device configuration zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">config_data</td><td>Configuration zone data is returned here. 88 bytes for ATSHA devices, 128 bytes for ATECC devices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga778a262b86fa1f8a38139cbae34376e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga778a262b86fa1f8a38139cbae34376e4">&#9670;&nbsp;</a></span>atcab_read_enc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_read_enc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>enc_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>enc_key_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command on a slot configured for encrypted reads and decrypts the data to return it as plaintext. </p>
<p>Data zone must be locked for this command to succeed. Can only read 32 byte blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>The slot ID to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Index of the 32 byte block within the slot to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Decrypted (plaintext) data from the read is returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enc_key</td><td>32 byte ReadKey for the slot being read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enc_key_id</td><td>KeyID of the ReadKey being used.</td></tr>
  </table>
  </dd>
</dl>
<p>returns ATCA_SUCCESS on success, otherwise an error code. </p>

</div>
</div>
<a id="ga782ca1e5b1574b2b6793c841be22b28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga782ca1e5b1574b2b6793c841be22b28b">&#9670;&nbsp;</a></span>atcab_read_pubkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_read_pubkey </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command to read an ECC P256 public key from a slot configured for clear reads. </p>
<p>This function assumes the public key is stored using the ECC public key format specified in the datasheet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number to read from. Only slots 8 to 15 are large enough for a public key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>Public key is returned here (64 bytes). Format will be the 32 byte X and Y big-endian integers concatenated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga96c434878e1f435e2cda5b0b5fec444f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96c434878e1f435e2cda5b0b5fec444f">&#9670;&nbsp;</a></span>atcab_read_serial_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_read_serial_number </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>serial_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command, which reads the 9 byte serial number of the device from the config zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">serial_number</td><td>9 byte serial number is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga098c4c2c724b90b7e2f4ecf12b9530b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga098c4c2c724b90b7e2f4ecf12b9530b7">&#9670;&nbsp;</a></span>atcab_read_sig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_read_sig </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command to read a 64 byte ECDSA P256 signature from a slot configured for clear reads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number to read from. Only slots 8 to 15 are large enough for a signature. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sig</td><td>Signature will be returned here (64 bytes). Format will be the 32 byte R and S big-endian integers concatenated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga3ce01f02f456c08891ca1d67cd3ed0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ce01f02f456c08891ca1d67cd3ed0eb">&#9670;&nbsp;</a></span>atcab_read_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_read_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command, which reads either 4 or 32 bytes of data from a given slot, configuration zone, or the OTP zone. </p>
<p>When reading a slot or OTP, data zone must be locked and the slot configuration must not be secret for a slot to be successfully read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to be read from device. Options are ATCA_ZONE_CONFIG, ATCA_ZONE_OTP, or ATCA_ZONE_DATA. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number for data zone and ignored for other zones. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>32 byte block index within the zone. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>4 byte work index within the block. Ignored for 32 byte reads. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Read data is returned here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data to be read. Must be either 4 or 32.</td></tr>
  </table>
  </dd>
</dl>
<p>returns ATCA_SUCCESS on success, otherwise an error code. </p>

</div>
</div>
<a id="ga3a061c1f96bb641b36fc56b6cb2dd4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a061c1f96bb641b36fc56b6cb2dd4e4">&#9670;&nbsp;</a></span>atcab_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_release </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>release (free) the global ATCADevice instance. This must be called in order to release or free up the interface. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns ATCA_SUCCESS . </dd></dl>

</div>
</div>
<a id="ga9506331ea7d454fe3c9b2585128c77aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9506331ea7d454fe3c9b2585128c77aa">&#9670;&nbsp;</a></span>atcab_secureboot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_secureboot </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>param2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Secure Boot command, which provides support for secure boot of an external MCU or MPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines what operations the SecureBoot command performs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param2</td><td>Not used, must be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">digest</td><td>Digest of the code to be verified (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature of the code to be verified (64 bytes). Can be NULL when using the FullStore mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mac</td><td>Validating MAC will be returned here (32 bytes). Can be NULL if not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga5c11f2012a03ec79cb46de8e03ed0534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c11f2012a03ec79cb46de8e03ed0534">&#9670;&nbsp;</a></span>atcab_secureboot_mac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_secureboot_mac </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>io_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Secure Boot command with encrypted digest and validated MAC response using the IO protection key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines what operations the SecureBoot command performs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">digest</td><td>Digest of the code to be verified (32 bytes). This is the plaintext digest (not encrypted). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature of the code to be verified (64 bytes). Can be NULL when using the FullStore mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Host nonce (20 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_key</td><td>IO protection key (32 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Verify result is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaeb4a36bc6992612cc3b1f950c0d020b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb4a36bc6992612cc3b1f950c0d020b7">&#9670;&nbsp;</a></span>atcab_selftest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_selftest </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>param2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the SelfTest command, which performs a test of one or more of the cryptographic engines within the ATECC608A chip. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Functions to test. Can be a bit field combining any of the following: SELFTEST_MODE_RNG, SELFTEST_MODE_ECDSA_VERIFY, SELFTEST_MODE_ECDSA_SIGN, SELFTEST_MODE_ECDH, SELFTEST_MODE_AES, SELFTEST_MODE_SHA, SELFTEST_MODE_ALL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param2</td><td>Currently unused, should be 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Results are returned here as a bit field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga31d269ccdafd08519a899a8aebf53df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31d269ccdafd08519a899a8aebf53df1">&#9670;&nbsp;</a></span>atcab_sha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sha </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the SHA command to compute a SHA-256 digest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Size of message parameter in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Message data to be hashed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>Digest is returned here (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gab3a32e171ca1c30bd31a216b32c9b5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3a32e171ca1c30bd31a216b32c9b5a4">&#9670;&nbsp;</a></span>atcab_sha_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sha_base </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>data_out_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command, which computes a SHA-256 or HMAC/SHA-256 digest for general purpose use by the host system. </p>
<p>Only the Start(0) and Compute(1) modes are available for ATSHA devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>SHA command mode Start(0), Update/Compute(1), End(2), Public(3), HMACstart(4), HMACend(5), Read_Context(6), or Write_Context(7). Also message digest target location for the ATECC608A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes in the message parameter or KeySlot for the HMAC key if Mode is HMACstart(4) or Public(3). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Message bytes to be hashed or Write_Context if restoring a context on the ATECC608A. Can be NULL if not required by the mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data_out</td><td>Data returned by the command (digest or context). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data_out_size</td><td>As input, the size of the data_out buffer. As output, the number of bytes returned in data_out.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga1db86704035048066a370815b657234d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1db86704035048066a370815b657234d">&#9670;&nbsp;</a></span>atcab_sha_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sha_end </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to complete SHA-256 or HMAC/SHA-256 operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>Digest from SHA-256 or HMAC/SHA-256 will be returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of any remaining data to include in hash. Max 64 bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Remaining data to include in hash. NULL if length is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gae655ce06583c08169170102fbb0b55c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae655ce06583c08169170102fbb0b55c9">&#9670;&nbsp;</a></span>atcab_sha_hmac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sha_hmac </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the SHA command to compute an HMAC/SHA-256 operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Message data to be hashed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of data in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_slot</td><td>Slot key id to use for the HMAC calculation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>Digest is returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Where to save the digest internal to the device. For ATECC608A, can be SHA_MODE_TARGET_TEMPKEY, SHA_MODE_TARGET_MSGDIGBUF, or SHA_MODE_TARGET_OUT_ONLY. For all other devices, SHA_MODE_TARGET_TEMPKEY is the only option.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaa4be9972396b7cadb08dd8e2199daf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4be9972396b7cadb08dd8e2199daf08">&#9670;&nbsp;</a></span>atcab_sha_hmac_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sha_hmac_finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to complete a HMAC/SHA-256 operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>HMAC/SHA-256 context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>HMAC/SHA-256 result is returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Where to save the digest internal to the device. For ATECC608A, can be SHA_MODE_TARGET_TEMPKEY, SHA_MODE_TARGET_MSGDIGBUF, or SHA_MODE_TARGET_OUT_ONLY. For all other devices, SHA_MODE_TARGET_TEMPKEY is the only option.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga310a017cddce9ef05071cb619b4b6db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga310a017cddce9ef05071cb619b4b6db9">&#9670;&nbsp;</a></span>atcab_sha_hmac_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sha_hmac_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to start an HMAC/SHA-256 operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>HMAC/SHA-256 context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_slot</td><td>Slot key id to use for the HMAC calculation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gae3343c160e80365b7e96bdfdc9b6365c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3343c160e80365b7e96bdfdc9b6365c">&#9670;&nbsp;</a></span>atcab_sha_hmac_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sha_hmac_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00916.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to add an arbitrary amount of message data to a HMAC/SHA-256 operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>HMAC/SHA-256 context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Message data to add </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of message data in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga74d1db50562642ce511fa7cbd384c2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74d1db50562642ce511fa7cbd384c2ab">&#9670;&nbsp;</a></span>atcab_sha_read_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sha_read_context </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>context_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to read the SHA-256 context back. Only for ATECC608A with SHA-256 contexts. HMAC not supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>Context data is returned here. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context_size</td><td>As input, the size of the context buffer in bytes. As output, the size of the returned context data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gae0a7ef89fce4cbd0ee1c76759cd93b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0a7ef89fce4cbd0ee1c76759cd93b9a">&#9670;&nbsp;</a></span>atcab_sha_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sha_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to initialize SHA-256 calculation engine. </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga39bd70baa7a4c7f4849fcf8b94d4d949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39bd70baa7a4c7f4849fcf8b94d4d949">&#9670;&nbsp;</a></span>atcab_sha_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sha_update </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to add 64 bytes of message data to the current context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>64 bytes of message data to add to add to operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga070fa80ac0d76f6816d9f7affbcfb120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga070fa80ac0d76f6816d9f7affbcfb120">&#9670;&nbsp;</a></span>atcab_sha_write_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sha_write_context </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>context_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to write (restore) a SHA-256 context into the the device. Only supported for ATECC608A with SHA-256 contexts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context data to be restored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context_size</td><td>Size of the context data in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga69b8282d1b1e0c54b9a7d286fed503b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69b8282d1b1e0c54b9a7d286fed503b8">&#9670;&nbsp;</a></span>atcab_sign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sign </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Sign command, to sign a 32-byte external message using the private key in the specified slot. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608A device or TempKey for other devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of the private key to be used to sign the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>32-byte message to be signed. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signature</td><td>Signature will be returned here. Format is R and S integers in big-endian format. 64 bytes for P256 curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga5c1e598bf3d4d25b522f42d6038a4268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c1e598bf3d4d25b522f42d6038a4268">&#9670;&nbsp;</a></span>atcab_sign_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sign_base </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Sign command, which generates a signature using the ECDSA algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines what the source of the message to be signed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Private key slot used to sign the message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signature</td><td>Signature is returned here. Format is R and S integers in big-endian format. 64 bytes for P256 curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga559add3e8b4f85a9d91fc0ed86aefa29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga559add3e8b4f85a9d91fc0ed86aefa29">&#9670;&nbsp;</a></span>atcab_sign_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sign_internal </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_invalidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_full_sn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Sign command to sign an internally generated message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of the private key to be used to sign the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_invalidate</td><td>Set to true if the signature will be used with the Verify(Invalidate) command. false for all other cases. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_full_sn</td><td>Set to true if the message should incorporate the device's full serial number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signature</td><td>Signature is returned here. Format is R and S integers in big-endian format. 64 bytes for P256 curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga9475e032c388144c5a0df45d1df182a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9475e032c388144c5a0df45d1df182a5">&#9670;&nbsp;</a></span>atcab_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>invoke sleep on the CryptoAuth device </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga416e4aeacf3acc35b1d5b76028c6947d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga416e4aeacf3acc35b1d5b76028c6947d">&#9670;&nbsp;</a></span>atcab_updateextra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_updateextra </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes UpdateExtra command to update the values of the two extra bytes within the Configuration zone (bytes 84 and 85). </p>
<p>Can also be used to decrement the limited use counter associated with the key in slot NewValue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines what operations the UpdateExtra command performs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_value</td><td>Value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga694d921c7bc17a0e158ef96e3d476700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga694d921c7bc17a0e158ef96e3d476700">&#9670;&nbsp;</a></span>atcab_verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_verify </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command, which takes an ECDSA [R,S] signature and verifies that it is correctly generated from a given message and public key. In all cases, the signature is an input to the command. </p>
<p>For the Stored, External, and ValidateExternal Modes, the contents of TempKey (or Message Digest Buffer in some cases for the ATECC608A) should contain the 32 byte message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Verify command mode and options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Stored mode, the slot containing the public key to be used for the verification. ValidateExternal mode, the slot containing the public key to be validated. External mode, KeyID contains the curve type to be used to Verify the signature. Validate or Invalidate mode, the slot containing the public key to be (in)validated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>If mode is External, the public key to be used for verification. X and Y integers in big-endian format. 64 bytes for P256 curve. NULL for all other modes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>If mode is Validate, the bytes used to generate the message for the validation (19 bytes). NULL for all other modes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mac</td><td>If mode indicates a validating MAC, then the MAC will will be returned here. Can be NULL otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga2c3e18de900ba705192963d08b37f600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c3e18de900ba705192963d08b37f600">&#9670;&nbsp;</a></span>atcab_verify_extern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_verify_extern </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608A device or TempKey for other devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>32 byte message to be verified. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>The public key to be used for verification. X and Y integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="ga17bf17c4786be097a0bb111a6f9d8ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17bf17c4786be097a0bb111a6f9d8ca6">&#9670;&nbsp;</a></span>atcab_verify_extern_mac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_verify_extern_mac </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>io_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command with verification MAC, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. This function is only available on the ATECC608A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>32 byte message to be verified. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>The public key to be used for verification. X and Y integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>System nonce (32 byte) used for the verification MAC. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_key</td><td>IO protection key for verifying the validation MAC. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="ga9393b545b2fa1fdd539672a0428a30ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9393b545b2fa1fdd539672a0428a30ab">&#9670;&nbsp;</a></span>atcab_verify_invalidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_verify_invalidate </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command in Invalidate mode which invalidates a previously validated public key stored in a slot. </p>
<p>This command can only be run after GenKey has been used to create a PubKey digest of the public key to be invalidated in TempKey (mode=0x10).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot containing the public key to be invalidated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>19 bytes of data used to build the verification message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, validation public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="gae8cc7670847805423ad591985eecd832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8cc7670847805423ad591985eecd832">&#9670;&nbsp;</a></span>atcab_verify_stored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_verify_stored </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command, which verifies a signature (ECDSA verify operation) with a public key stored in the device. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608A device or TempKey for other devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>32 byte message to be verified. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot containing the public key to be used in the verification. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="gaa52cdbbfd2f089d8eb42ef2640204ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa52cdbbfd2f089d8eb42ef2640204ca7">&#9670;&nbsp;</a></span>atcab_verify_stored_mac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_verify_stored_mac </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>io_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command with verification MAC, which verifies a signature (ECDSA verify operation) with a public key stored in the device. This function is only available on the ATECC608A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>32 byte message to be verified. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot containing the public key to be used in the verification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>System nonce (32 byte) used for the verification MAC. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_key</td><td>IO protection key for verifying the validation MAC. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="gacf9a0c7772ebb65b87c4a4788850702b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf9a0c7772ebb65b87c4a4788850702b">&#9670;&nbsp;</a></span>atcab_verify_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_verify_validate </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command in Validate mode to validate a public key stored in a slot. </p>
<p>This command can only be run after GenKey has been used to create a PubKey digest of the public key to be validated in TempKey (mode=0x10).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot containing the public key to be validated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>19 bytes of data used to build the verification message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, validation public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="gaff701132013eaac5600dd9fd6253505d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff701132013eaac5600dd9fd6253505d">&#9670;&nbsp;</a></span>atcab_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_version </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ver_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>basic API methods are all prefixed with atcab_ (CryptoAuthLib Basic) the fundamental premise of the basic API is it is based on a single interface instance and that instance is global, so all basic API commands assume that one global device is the one to operate on. </p>
<p>returns a version string for the CryptoAuthLib release. The format of the version string returned is "yyyymmdd" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ver_str</td><td>ptr to space to receive version string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gad3bc620aedd9322d160eece0d8d20c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3bc620aedd9322d160eece0d8d20c82">&#9670;&nbsp;</a></span>atcab_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_wakeup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>wakeup the CryptoAuth device </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gabf2b29b4d3ae926b63c403d084380dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf2b29b4d3ae926b63c403d084380dbe">&#9670;&nbsp;</a></span>atcab_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Write command, which writes either one four byte word or a 32-byte block to one of the EEPROM zones on the device. Depending upon the value of the WriteConfig byte for this slot, the data may be required to be encrypted by the system prior to being sent to the device. This command cannot be used to write slots configured as ECC private keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone/Param1 for the write command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Address/Param2 for the write command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Plain-text data to be written or cipher-text for encrypted writes. 32 or 4 bytes depending on bit 7 in the zone. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac</td><td>MAC required for encrypted writes (32 bytes). Set to NULL if not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gac395a7e195aa3cf28b48de345755feb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac395a7e195aa3cf28b48de345755feb0">&#9670;&nbsp;</a></span>atcab_write_bytes_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_write_bytes_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Write command, which writes data into the configuration, otp, or data zones with a given byte offset and length. Offset and length must be multiples of a word (4 bytes). </p>
<p>Config zone must be unlocked for writes to that zone. If data zone is unlocked, only 32-byte writes are allowed to slots and OTP and the offset and length must be multiples of 32 or the write will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to write data to: <a class="el" href="a00912.html#gadd3796a1d4de55604283aef5a70f7945" title="Configuration zone. ">ATCA_ZONE_CONFIG(0)</a>, <a class="el" href="a00912.html#ga547efc6fa3cb0501b2e53f80023dff7e" title="OTP (One Time Programming) zone. ">ATCA_ZONE_OTP(1)</a>, or <a class="el" href="a00912.html#ga4c65b241280290fae9fd4faa9d7a292b" title="Data zone. ">ATCA_ZONE_DATA(2)</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>If zone is <a class="el" href="a00912.html#ga4c65b241280290fae9fd4faa9d7a292b" title="Data zone. ">ATCA_ZONE_DATA(2)</a>, the slot number to write to. Ignored for all other zones. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset_bytes</td><td>Byte offset within the zone to write to. Must be a multiple of a word (4 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes to be written. Must be a multiple of a word (4 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gab25ca44957dff1c2df34607738ca3bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab25ca44957dff1c2df34607738ca3bf7">&#9670;&nbsp;</a></span>atcab_write_config_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_write_config_counter </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>counter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counter_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize one of the monotonic counters in device with a specific value. </p>
<p>The monotonic counters are stored in the configuration zone using a special format. This encodes a binary count value into the 8 byte encoded value required. Can only be set while the configuration zone is unlocked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>Counter to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_value</td><td>Counter value to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga0777a86aa412a97b19cc72a12c171b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0777a86aa412a97b19cc72a12c171b94">&#9670;&nbsp;</a></span>atcab_write_config_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_write_config_zone </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>config_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Write command, which writes the configuration zone. </p>
<p>First 16 bytes are skipped as they are not writable. LockValue and LockConfig are also skipped and can only be changed via the Lock command.</p>
<p>This command may fail if UserExtra and/or Selector bytes have already been set to non-zero values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config_data</td><td>Data to the config zone data. This should be 88 bytes for SHA devices and 128 bytes for ECC devices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga14cf75d1be264ac1125087d76ee6344c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14cf75d1be264ac1125087d76ee6344c">&#9670;&nbsp;</a></span>atcab_write_enc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_write_enc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>enc_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>enc_key_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Write command, which performs an encrypted write of a 32 byte block into given slot. </p>
<p>The function takes clear text bytes and encrypts them for writing over the wire. Data zone must be locked and the slot configuration must be set to encrypted write for the block to be successfully written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot ID to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Index of the 32 byte block to write in the slot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>32 bytes of clear text data to be written to the slot </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enc_key</td><td>WriteKey to encrypt with for writing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enc_key_id</td><td>The KeyID of the WriteKey</td></tr>
  </table>
  </dd>
</dl>
<p>returns ATCA_SUCCESS on success, otherwise an error code. </p>

</div>
</div>
<a id="ga47cbedeb3c3e9f7cbf2b9433cd60d1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47cbedeb3c3e9f7cbf2b9433cd60d1aa">&#9670;&nbsp;</a></span>atcab_write_pubkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_write_pubkey </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Write command, which writes a public key to a data slot in the device format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number to write. Only slots 8 to 15 are large enough to store a public key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key to write into the slot specified. X and Y integers in big-endian format. 64 bytes for P256 curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga1f5a6bbcf4f840803635fb8951b3a7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f5a6bbcf4f840803635fb8951b3a7e2">&#9670;&nbsp;</a></span>atcab_write_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_write_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Write command, which writes either 4 or 32 bytes of data into a device zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Device zone to write to (0=config, 1=OTP, 2=data). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>If writing to the data zone, it is the slot to write to, otherwise it should be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>32-byte block to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>4-byte word within the specified block to write to. If performing a 32-byte write, this should be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to be written. Must be either 4 or 32.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga3cf48d232ffbc9000c4d8547120f8b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cf48d232ffbc9000c4d8547120f8b2d">&#9670;&nbsp;</a></span>base64Char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char base64Char </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>rules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the base 64 character of the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>index to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rules</td><td>base64 ruleset to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the base 64 character of the given index </dd></dl>

</div>
</div>
<a id="ga175f401662f82c1e2ef822a9e1fd0b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga175f401662f82c1e2ef822a9e1fd0b57">&#9670;&nbsp;</a></span>base64Index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t base64Index </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>rules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the base 64 index of the given character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rules</td><td>base64 ruleset to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the base 64 index of the given character </dd></dl>

</div>
</div>
<a id="ga592c23e94097ad5e212beb6390aa88c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga592c23e94097ad5e212beb6390aa88c6">&#9670;&nbsp;</a></span>isAlpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isAlpha </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a character is an ASCII representation of hex ((c &gt;= 'A') and (c &lt;= 'F')) || ((c &gt;= 'a') and (c &lt;= 'f')) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is a hex </dd></dl>

</div>
</div>
<a id="gac873a37c53fdd922d5b36efd737e3ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac873a37c53fdd922d5b36efd737e3ec3">&#9670;&nbsp;</a></span>isBase64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isBase64 </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>rules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this character is a valid base 64 character or if this is whitespace (A character can be included in a valid base 64 string). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rules</td><td>base64 ruleset to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character can be included in a valid base 64 string </dd></dl>

</div>
</div>
<a id="gad10d15454308230fbef54bdd43001ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad10d15454308230fbef54bdd43001ed2">&#9670;&nbsp;</a></span>isBase64Digit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isBase64Digit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>rules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this character is a valid base 64 character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rules</td><td>base64 ruleset to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character can be included in a valid base 64 string </dd></dl>

</div>
</div>
<a id="ga7a929bf65cbc777bab7e533a2755cfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a929bf65cbc777bab7e533a2755cfad">&#9670;&nbsp;</a></span>isDigit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isDigit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a character is an ASCII representation of a digit ((c ge '0') and (c le '9')) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is a digit </dd></dl>

</div>
</div>
<a id="gab7ca9ee391118aafe6f3cf7df4fa5de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7ca9ee391118aafe6f3cf7df4fa5de3">&#9670;&nbsp;</a></span>isHex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isHex </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this character is a valid hex character or if this is whitespace (The character can be included in a valid hexstring). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character can be included in a valid hexstring </dd></dl>

</div>
</div>
<a id="ga78abefc293c0a04d8ef649c94c8a1057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78abefc293c0a04d8ef649c94c8a1057">&#9670;&nbsp;</a></span>isHexAlpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isHexAlpha </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a character is an ASCII representation of hex ((c &gt;= 'A') and (c &lt;= 'F')) || ((c &gt;= 'a') and (c &lt;= 'f')) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is a hex </dd></dl>

</div>
</div>
<a id="ga39003da4dc8a0b8999f1325c2f96f641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39003da4dc8a0b8999f1325c2f96f641">&#9670;&nbsp;</a></span>isHexDigit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isHexDigit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this character is a valid hex character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character can be included in a valid hexstring </dd></dl>

</div>
</div>
<a id="gab3db1b55b966b792e8308a1819933c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3db1b55b966b792e8308a1819933c0e">&#9670;&nbsp;</a></span>isWhiteSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isWhiteSpace </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a character is whitespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is whitespace </dd></dl>

</div>
</div>
<a id="gad017ae33af5a7ea062cea7d54de675a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad017ae33af5a7ea062cea7d54de675a8">&#9670;&nbsp;</a></span>packHex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00128.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> packHex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ascii_hex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ascii_hex_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>packed_hex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>packed_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove white space from a ASCII hex string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ascii_hex</td><td>Initial hex string to remove white space from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ascii_hex_len</td><td>Length of the initial hex string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packed_hex</td><td>Resulting hex string without white space </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">packed_len</td><td>In: Size to packed_hex buffer Out: Number of bytes in the packed hex string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga692423e9c45adde594c36360756b8882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga692423e9c45adde594c36360756b8882">&#9670;&nbsp;</a></span>_gDevice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00913.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> _gDevice</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga50731dca3906502d901f5762aa4d9e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50731dca3906502d901f5762aa4d9e71">&#9670;&nbsp;</a></span>atcab_b64rules_default</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t atcab_b64rules_default[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga87ae4178e0a5543d5b2192f26e049bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87ae4178e0a5543d5b2192f26e049bd2">&#9670;&nbsp;</a></span>atcab_b64rules_mime</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t atcab_b64rules_mime[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1cccbbcdbcb7230cc0f8ea8a596feebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cccbbcdbcb7230cc0f8ea8a596feebe">&#9670;&nbsp;</a></span>atcab_b64rules_urlsafe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t atcab_b64rules_urlsafe[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
